<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WarpMind Memory Demo - Proxy-Compatible AI Memory</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .content {
            padding: 30px;
        }

        .setup-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            border: 1px solid #e9ecef;
        }

        .setup-section h3 {
            color: #495057;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #495057;
        }

        input[type="text"], input[type="password"], textarea, select {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        input[type="text"]:focus, input[type="password"]:focus, textarea:focus, select:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
        }

        .btn {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.4);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
        }

        .memory-section {
            margin-bottom: 30px;
        }

        .section-title {
            color: #495057;
            border-bottom: 2px solid #4facfe;
            padding-bottom: 10px;
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .form-grid {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 15px;
            align-items: end;
        }

        .tag-input {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }

        .tag {
            background: #e3f2fd;
            color: #1565c0;
            padding: 4px 8px;
            border-radius: 20px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .tag .remove {
            cursor: pointer;
            font-weight: bold;
        }

        .memories-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .memory-card {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 10px;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .memory-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .memory-content {
            font-size: 14px;
            line-height: 1.5;
            margin-bottom: 15px;
            color: #495057;
        }

        .memory-meta {
            font-size: 12px;
            color: #6c757d;
            margin-bottom: 10px;
        }

        .memory-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 15px;
        }

        .memory-actions {
            display: flex;
            gap: 10px;
        }

        .search-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .search-results {
            margin-top: 20px;
        }

        .result-item {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .relevance-score {
            background: #4facfe;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
        }

        .status {
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }

        .status.success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .status.error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        .status.info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .demo-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }

        .emoji {
            font-size: 1.2em;
            margin-right: 5px;
        }

        @media (max-width: 768px) {
            .form-grid {
                grid-template-columns: 1fr;
            }
            
            .memories-grid {
                grid-template-columns: 1fr;
            }
            
            .stats {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><span class="emoji">üß†</span>WarpMind Memory Demo</h1>
            <p>Explore semantic memory storage, search, and management capabilities with proxy-compatible AI services</p>
        </div>

        <div class="content">
            <!-- API Setup Section -->
            <div class="setup-section">
                <h3><span class="emoji">üîë</span>API Configuration</h3>
                <div class="input-group">
                    <label for="serverURL">Server Endpoint:</label>
                    <input type="text" id="serverURL" placeholder="https://warp.cs.au.dk/mind/v1" value="https://warp.cs.au.dk/mind/v1">
                    <small style="color: #6c757d; font-size: 12px; margin-top: 5px; display: block;">
                        Enter the base URL for your WarpMind-compatible API endpoint
                    </small>
                </div>
                <div class="input-group">
                    <label for="apiKey">API Key (Optional):</label>
                    <input type="password" id="apiKey" placeholder="Enter your API key (leave empty for automatic prompting)">
                    <small style="color: #6c757d; font-size: 12px; margin-top: 5px; display: block;">
                        If no API key is provided, you will be prompted automatically when needed
                    </small>
                </div>
                <div style="display: flex; gap: 10px; margin-top: 15px;">
                    <button id="initializeBtn" class="btn">
                        <span class="emoji">üöÄ</span>Initialize WarpMind
                    </button>
                    <button id="resetConfigBtn" class="btn" style="background: #6c757d;">
                        <span class="emoji">üîÑ</span>Reset to Defaults
                    </button>
                </div>
                <div id="configStatus" class="status" style="margin-top: 10px; display: none;"></div>
            </div>

            <!-- Status Messages -->
            <div id="status" class="status"></div>

            <!-- Statistics -->
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-number" id="totalMemories">0</div>
                    <div class="stat-label">Total Memories</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="totalTags">0</div>
                    <div class="stat-label">Unique Tags</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="lastSearchResults">0</div>
                    <div class="stat-label">Last Search Results</div>
                </div>
            </div>

            <!-- Demo Actions -->
            <div class="demo-actions">
                <button id="loadSamplesBtn" class="btn btn-secondary">
                    <span class="emoji">üìö</span>Load Sample Memories
                </button>
                <button id="clearAllBtn" class="btn btn-danger">
                    <span class="emoji">üóëÔ∏è</span>Clear All Memories
                </button>
                <button id="exportBtn" class="btn btn-secondary">
                    <span class="emoji">üíæ</span>Export Memories
                </button>
                <button id="importBtn" class="btn btn-secondary">
                    <span class="emoji">üì•</span>Import Memories
                </button>
            </div>

            <!-- Add Memory Section -->
            <div class="memory-section">
                <h2 class="section-title"><span class="emoji">üí≠</span>Add New Memory</h2>
                <div class="form-grid">
                    <div>
                        <div class="input-group">
                            <label for="memoryContent">Memory Content:</label>
                            <textarea id="memoryContent" rows="3" placeholder="Enter the content you want to remember..."></textarea>
                        </div>
                        <div class="input-group">
                            <label for="memoryTags">Tags (comma-separated):</label>
                            <input type="text" id="memoryTags" placeholder="work, important, meeting">
                        </div>
                    </div>
                    <button id="addMemoryBtn" class="btn">
                        <span class="emoji">üíæ</span>Remember
                    </button>
                </div>
            </div>

            <!-- Search Section -->
            <div class="search-section">
                <h2 class="section-title"><span class="emoji">üîç</span>Search Memories</h2>
                <div class="form-grid">
                    <div>
                        <div class="input-group">
                            <label for="searchQuery">Search Query:</label>
                            <input type="text" id="searchQuery" placeholder="Enter your search query...">
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                            <div class="input-group">
                                <label for="searchLimit">Results Limit:</label>
                                <select id="searchLimit">
                                    <option value="5">5 results</option>
                                    <option value="10">10 results</option>
                                    <option value="20">20 results</option>
                                    <option value="50">50 results</option>
                                </select>
                            </div>
                            <div class="input-group">
                                <label for="searchType">Search Type:</label>
                                <select id="searchType">
                                    <option value="semantic">Semantic (with embeddings)</option>
                                    <option value="keyword">Keyword only</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <button id="searchBtn" class="btn">
                        <span class="emoji">üîç</span>Search
                    </button>
                </div>
                <div id="searchResults" class="search-results"></div>
            </div>

            <!-- Memory Tool Chat Section -->
            <div class="search-section">
                <h2 class="section-title"><span class="emoji">ü§ñ</span>Memory Tool Chat</h2>
                <p style="margin-bottom: 15px; color: #6c757d; font-size: 14px;">
                    Try chatting with the AI! When you explicitly ask it to remember or recall information, 
                    it will automatically search your stored memories. Try phrases like "What do you remember about..." 
                    or "Can you recall..." vs general questions.
                </p>
                
                <div class="form-grid">
                    <div>
                        <div class="input-group">
                            <label for="chatMessage">Chat Message:</label>
                            <textarea id="chatMessage" rows="3" placeholder="Try: 'What do you remember about my work projects?' or 'What is the capital of France?'"></textarea>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr auto; gap: 15px; align-items: center;">
                            <small style="color: #6c757d; font-size: 12px;">
                                <strong>Memory tool examples:</strong> "What do you remember about...", "Can you recall...", "Do you have any memories of..."<br>
                                <strong>Regular chat:</strong> General questions, current topics, knowledge queries
                            </small>
                            <div class="input-group" style="margin: 0;">
                                <label for="maxTokens" style="font-size: 12px;">Max Tokens:</label>
                                <select id="maxTokens" style="font-size: 12px; padding: 6px;">
                                    <option value="100">100</option>
                                    <option value="200" selected>200</option>
                                    <option value="300">300</option>
                                    <option value="500">500</option>
                                </select>
                            </div>
                        </div>
                        <div style="display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px;">
                            <button type="button" class="btn btn-secondary btn-small" onclick="document.getElementById('chatMessage').value = 'What do you remember about my work projects?'">
                                Try: Work Projects
                            </button>
                            <button type="button" class="btn btn-secondary btn-small" onclick="document.getElementById('chatMessage').value = 'Can you recall any personal preferences I stored?'">
                                Try: Personal Preferences
                            </button>
                            <button type="button" class="btn btn-secondary btn-small" onclick="document.getElementById('chatMessage').value = 'What is the capital of France?'">
                                Try: General Question
                            </button>
                        </div>
                    </div>
                    <button id="chatBtn" class="btn">
                        <span class="emoji">üí¨</span>Chat
                    </button>
                </div>
                
                <div id="chatResponse" class="search-results" style="display: none;">
                    <div class="result-item">
                        <div id="chatResponseText"></div>
                    </div>
                </div>
            </div>

            <!-- All Memories Section -->
            <div class="memory-section">
                <h2 class="section-title"><span class="emoji">üìù</span>All Memories</h2>
                <div id="memoriesContainer" class="memories-grid">
                    <!-- Memories will be displayed here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Include WarpMind library -->
    <script src="../dist/warpmind.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            let warpMind = null;
            let memories = [];

            // --- DOM Element References ---
            const initializeBtn = document.getElementById('initializeBtn');
            const resetConfigBtn = document.getElementById('resetConfigBtn');
            const loadSamplesBtn = document.getElementById('loadSamplesBtn');
            const clearAllBtn = document.getElementById('clearAllBtn');
            const exportBtn = document.getElementById('exportBtn');
            const importBtn = document.getElementById('importBtn');
            const addMemoryBtn = document.getElementById('addMemoryBtn');
            const searchBtn = document.getElementById('searchBtn');
            const chatBtn = document.getElementById('chatBtn');
            const memoriesContainer = document.getElementById('memoriesContainer');

            // --- Event Listeners ---
            initializeBtn.addEventListener('click', initializeWarpMind);
            resetConfigBtn.addEventListener('click', resetConfiguration);
            loadSamplesBtn.addEventListener('click', loadSampleMemories);
            clearAllBtn.addEventListener('click', clearAllMemories);
            exportBtn.addEventListener('click', exportMemories);
            importBtn.addEventListener('click', importMemories);
            addMemoryBtn.addEventListener('click', addMemory);
            searchBtn.addEventListener('click', searchMemories);
            chatBtn.addEventListener('click', chatWithMemoryTool);

            // Event delegation for delete buttons
            memoriesContainer.addEventListener('click', (event) => {
                const deleteButton = event.target.closest('.delete-btn');
                if (deleteButton) {
                    const memoryId = deleteButton.dataset.id;
                    if (memoryId) {
                        deleteMemory(memoryId);
                    }
                }
            });

                        // Configuration management
            const DEFAULT_CONFIG = {
                baseURL: 'https://warp.cs.au.dk/mind/v1',
                model: 'gpt-5-mini',
                memoryToolEnabled: true,
                memoryToolExplicitOnly: true,
                memoryToolMaxResults: 5
            };

            // Load configuration from localStorage or use defaults
            function loadConfiguration() {
                const savedConfig = localStorage.getItem('warpMind-memory-demo-config');
                if (savedConfig) {
                    try {
                        return JSON.parse(savedConfig);
                    } catch (e) {
                        console.warn('Failed to parse saved config, using defaults');
                        return DEFAULT_CONFIG;
                    }
                }
                return DEFAULT_CONFIG;
            }

            // Save configuration to localStorage
            function saveConfiguration(config) {
                localStorage.setItem('warpMind-memory-demo-config', JSON.stringify(config));
            }

            // Show configuration status message
            function showConfigStatus(message, type) {
                const statusDiv = document.getElementById('configStatus');
                statusDiv.style.display = 'block';
                statusDiv.className = `status ${type}`;
                statusDiv.textContent = message;
                
                // Hide after 3 seconds unless it's an error
                if (type !== 'error') {
                    setTimeout(() => {
                        statusDiv.style.display = 'none';
                    }, 3000);
                }
            }

            // Initialize configuration form
            function initializeForm() {
                const savedConfig = loadConfiguration();
                document.getElementById('serverURL').value = savedConfig.baseURL || DEFAULT_CONFIG.baseURL;
                document.getElementById('apiKey').value = savedConfig.apiKey || '';
            }

            // Reset configuration to defaults
            function resetConfiguration() {
                document.getElementById('serverURL').value = DEFAULT_CONFIG.baseURL;
                document.getElementById('apiKey').value = '';
                
                saveConfiguration(DEFAULT_CONFIG);
                showConfigStatus('Configuration reset to defaults', 'info');
            }

            // Initialize WarpMind with configuration
            async function initializeWarpMind() {
                try {
                    const serverURL = document.getElementById('serverURL').value.trim();
                    const apiKey = document.getElementById('apiKey').value.trim();
                    
                    if (!serverURL) {
                        showConfigStatus('Please enter a server URL', 'error');
                        return;
                    }

                    // Build configuration object
                    const config = {
                        ...DEFAULT_CONFIG,
                        baseURL: serverURL
                    };
                    
                    if (apiKey) {
                        config.apiKey = apiKey;
                    }

                    // Save configuration
                    saveConfiguration(config);
                    
                    // Initialize WarpMind
                    warpMind = new WarpMind(config);

                    showConfigStatus('WarpMind initialized successfully!', 'success');
                    showStatus('WarpMind initialized successfully! Memory tool enabled for chat ü§ñüß†', 'success');
                    
                    if (apiKey) {
                        showStatus(`Using server: ${serverURL} with provided API key`, 'info');
                    } else {
                        showStatus(`Using server: ${serverURL} - will prompt for API key when needed`, 'info');
                    }
                    
                    await loadAllMemories();
                } catch (error) {
                    showConfigStatus(`Failed to initialize WarpMind: ${error.message}`, 'error');
                    showStatus(`Failed to initialize WarpMind: ${error.message}`, 'error');
                }
            }

            // Load sample memories
            async function loadSampleMemories() {
                if (!warpMind) {
                    showStatus('Please initialize WarpMind first.', 'error');
                    return;
                }

                const sampleMemories = [
                    { content: 'Team meeting every Monday at 9 AM to discuss project updates.', tags: ['work', 'meeting'] },
                    { content: 'Remember to buy milk, bread, and eggs from the grocery store.', tags: ['personal', 'shopping'] },
                    { content: 'Doctor appointment scheduled for Friday at 3 PM.', tags: ['health', 'appointment'] },
                    { content: 'Flight to Paris booked for next month - confirmation number ABC123.', tags: ['travel', 'vacation'] },
                    { content: 'Research paper on machine learning is due next week.', tags: ['study', 'AI', 'deadline'] }
                ];

                try {
                    showStatus('Loading sample memories...', 'info');
                    for (const memory of sampleMemories) {
                        await warpMind.remember(memory.content, { tags: memory.tags });
                    }
                    showStatus('Sample memories loaded successfully!', 'success');
                    await loadAllMemories();
                } catch (error) {
                    showStatus(`Error loading sample memories: ${error.message}`, 'error');
                }
            }

            // Clear all memories
            async function clearAllMemories() {
                if (!warpMind) {
                    showStatus('Please initialize WarpMind first.', 'error');
                    return;
                }

                const confirmed = confirm("Are you sure you want to clear all memories? This action cannot be undone.");
                if (!confirmed) return;

                try {
                    showStatus('Clearing all memories...', 'info');
                    // Get all memories first, then delete them one by one
                    const allMemories = await warpMind.getMemories();
                    for (const memory of allMemories) {
                        await warpMind.forget(memory.id);
                    }
                    showStatus('All memories cleared successfully!', 'success');
                    await loadAllMemories();
                } catch (error) {
                    showStatus(`Error clearing memories: ${error.message}`, 'error');
                }
            }

            // Export memories using the new exportMemoriesToFile method
            async function exportMemories() {
                if (!warpMind) {
                    showStatus('Please initialize WarpMind first.', 'error');
                    return;
                }

                try {
                    showStatus('Exporting memories...', 'info');
                    const result = await warpMind.exportMemoriesToFile({
                        includeEmbeddings: false // Don't include embeddings to keep file size smaller
                    });

                    if (result.exported === 0) {
                        showStatus('No memories to export. Add some memories first.', 'info');
                        return;
                    }

                    showStatus(`Successfully exported ${result.exported} memories to ${result.filename}!`, 'success');
                } catch (error) {
                    showStatus(`Error exporting memories: ${error.message}`, 'error');
                }
            }

            // Add a new memory
            async function addMemory() {
                if (!warpMind) {
                    showStatus('Please initialize WarpMind first.', 'error');
                    return;
                }

                const content = document.getElementById('memoryContent').value.trim();
                const tags = document.getElementById('memoryTags').value.trim().split(',').map(tag => tag.trim()).filter(tag => tag);

                if (!content) {
                    showStatus('Memory content is required.', 'error');
                    return;
                }

                try {
                    showStatus('Adding new memory...', 'info');
                    await warpMind.remember(content, { tags });
                    showStatus('Memory added successfully!', 'success');
                    document.getElementById('memoryContent').value = '';
                    document.getElementById('memoryTags').value = '';
                    await loadAllMemories();
                } catch (error) {
                    showStatus(`Error adding memory: ${error.message}`, 'error');
                }
            }

            // Search for memories
            async function searchMemories() {
                if (!warpMind) {
                    showStatus('Please initialize WarpMind first.', 'error');
                    return;
                }

                const query = document.getElementById('searchQuery').value.trim();
                const limit = parseInt(document.getElementById('searchLimit').value);
                const type = document.getElementById('searchType').value;

                if (!query) {
                    showStatus('Search query is required.', 'error');
                    return;
                }

                try {
                    showStatus('Searching memories...', 'info');
                    const searchOptions = { limit };
                    if (type === 'keyword') {
                        searchOptions.useKeywordSearch = true;
                    }
                    
                    const results = await warpMind.recall(query, searchOptions);
                    showStatus(`Found ${results.length} memories`, 'success');
                    displaySearchResults(results);
                    document.getElementById('lastSearchResults').textContent = results.length;
                } catch (error) {
                    showStatus(`Error searching memories: ${error.message}`, 'error');
                }
            }

            // Display search results
            function displaySearchResults(results) {
                const container = document.getElementById('searchResults');
                container.innerHTML = '';

                if (results.length === 0) {
                    container.innerHTML = '<p>No memories found matching your search criteria.</p>';
                    return;
                }

                results.forEach(memory => {
                    const div = document.createElement('div');
                    div.className = 'result-item';
                    div.innerHTML = `
                        <div class="memory-content">${escapeHtml(memory.content)}</div>
                        <div class="memory-meta">
                            <div>Tags: ${memory.tags ? memory.tags.join(', ') : 'None'}</div>
                            ${memory.relevanceScore !== undefined ? `<div class="relevance-score">Score: ${memory.relevanceScore.toFixed(3)}</div>` : ''}
                        </div>
                        <div class="memory-actions">
                            <button class="btn btn-danger btn-small delete-btn" data-id="${memory.id}">
                                <span class="emoji">üóëÔ∏è</span>Delete
                            </button>
                        </div>
                    `;
                    container.appendChild(div);
                });
            }

            // Chat with memory tool
            async function chatWithMemoryTool() {
                if (!warpMind) {
                    showStatus('Please initialize WarpMind first.', 'error');
                    return;
                }

                const message = document.getElementById('chatMessage').value.trim();
                const maxTokens = parseInt(document.getElementById('maxTokens').value);

                if (!message) {
                    showStatus('Chat message is required.', 'error');
                    return;
                }

                try {
                    showStatus('Sending message to AI...', 'info');
                    chatBtn.disabled = true;
                    
                    // Configure WarpMind for this chat request
                    const originalMaxTokens = warpMind.maxTokens;
                    warpMind.maxTokens = maxTokens;
                    
                    const response = await warpMind.chat([
                        { role: 'user', content: message }
                    ]);
                    
                    // Restore original maxTokens
                    warpMind.maxTokens = originalMaxTokens;
                    
                    document.getElementById('chatResponseText').textContent = response;
                    document.getElementById('chatResponse').style.display = 'block';
                    showStatus('Chat response received!', 'success');
                    
                } catch (error) {
                    showStatus(`Chat error: ${error.message}`, 'error');
                    document.getElementById('chatResponse').style.display = 'none';
                } finally {
                    chatBtn.disabled = false;
                }
            }

            // Load all memories
            async function loadAllMemories() {
                if (!warpMind) {
                    return;
                }

                try {
                    const allMemories = await warpMind.getMemories();
                    memories = allMemories; // Update global memories array
                    displayMemories(allMemories);
                    updateStatistics();
                } catch (error) {
                    showStatus(`Error loading memories: ${error.message}`, 'error');
                }
            }

            // Display memories in the grid
            function displayMemories(memoriesList) {
                const container = document.getElementById('memoriesContainer');
                container.innerHTML = '';

                if (memoriesList.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #6c757d; font-style: italic; grid-column: 1 / -1;">No memories stored yet. Add some memories to get started!</p>';
                    return;
                }

                memoriesList.forEach(memory => {
                    const div = document.createElement('div');
                    div.className = 'memory-card';
                    div.innerHTML = `
                        <div class="memory-content">${escapeHtml(memory.content)}</div>
                        <div class="memory-meta">
                            <strong>ID:</strong> ${memory.id.slice(0, 8)}...<br>
                            <strong>Created:</strong> ${new Date(memory.timestamp).toLocaleString()}
                        </div>
                        <div class="memory-tags">
                            ${memory.tags ? memory.tags.map(tag => `<span class="tag">${escapeHtml(tag)}</span>`).join('') : ''}
                        </div>
                        <div class="memory-actions">
                            <button class="btn btn-danger btn-small delete-btn" data-id="${memory.id}">
                                <span class="emoji">üóëÔ∏è</span>Delete
                            </button>
                        </div>
                    `;
                    container.appendChild(div);
                });
            }

            // Delete a memory
            async function deleteMemory(memoryId) {
                if (!warpMind) {
                    showStatus('Please initialize WarpMind first.', 'error');
                    return;
                }

                const confirmed = confirm("Are you sure you want to delete this memory? This action cannot be undone.");
                if (!confirmed) return;

                try {
                    showStatus('Deleting memory...', 'info');
                    await warpMind.forget(memoryId);
                    showStatus('Memory deleted successfully!', 'success');
                    await loadAllMemories();
                } catch (error) {
                    showStatus(`Error deleting memory: ${error.message}`, 'error');
                }
            }

            // Update statistics display
            function updateStatistics() {
                document.getElementById('totalMemories').textContent = memories.length;
                
                const allTags = memories.flatMap(memory => memory.tags || []);
                const uniqueTags = new Set(allTags);
                document.getElementById('totalTags').textContent = uniqueTags.size;
            }

            // Escape HTML special characters
            function escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            // Show status messages
            function showStatus(message, type = 'info') {
                const statusDiv = document.getElementById('status');
                statusDiv.className = `status ${type}`;
                statusDiv.innerText = message;
                statusDiv.style.display = 'block';

                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 5000);
            }

            // Hide status messages
            function hideStatus() {
                const statusDiv = document.getElementById('status');
                statusDiv.style.display = 'none';
            }

            // Import memories using the new importMemoriesFromFile method
            async function importMemories() {
                if (!warpMind) {
                    showStatus('Please initialize WarpMind first.', 'error');
                    return;
                }

                try {
                    showStatus('Opening file picker...', 'info');
                    const result = await warpMind.importMemoriesFromFile({
                        merge: true, // Merge with existing memories
                        skipDuplicates: true, // Skip duplicate content
                        regenerateEmbeddings: true // Generate new embeddings
                    });

                    // Show detailed import results
                    let message = `Import completed! Imported: ${result.imported}, Skipped: ${result.skipped}`;
                    if (result.errors.length > 0) {
                        message += `, Errors: ${result.errors.length}`;
                        console.warn('Import errors:', result.errors);
                    }
                    message += ` from ${result.filename}`;

                    showStatus(message, result.errors.length > 0 ? 'info' : 'success');
                    await loadAllMemories(); // Refresh the display
                } catch (error) {
                    if (error.message === 'File selection cancelled') {
                        showStatus('File selection cancelled.', 'info');
                    } else {
                        showStatus(`Error importing memories: ${error.message}`, 'error');
                    }
                }
            }

            // Initialize form with saved configuration after all functions are defined
            initializeForm();
        });
    </script>
</body>
</html>
