<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WarpMind PDF Reader Demo</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            margin-bottom: 30px;
            text-align: center;
        }
        .section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }
        .section h2 {
            color: #34495e;
            margin-top: 0;
        }
        .file-input {
            margin-bottom: 15px;
        }
        .file-input input[type="file"] {
            width: 100%;
            padding: 10px;
            border: 2px dashed #bdc3c7;
            border-radius: 6px;
            background: white;
        }
        .url-input {
            margin-bottom: 15px;
        }
        .url-input input[type="url"] {
            width: 100%;
            padding: 12px;
            border: 1px solid #bdc3c7;
            border-radius: 6px;
            font-size: 14px;
        }
        .button {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        .button:hover {
            background: #2980b9;
        }
        .button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #ecf0f1;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: #3498db;
            transition: width 0.3s ease;
            border-radius: 10px;
        }
        .chat-container {
            margin-top: 20px;
        }
        .chat-input {
            width: 100%;
            padding: 12px;
            border: 1px solid #bdc3c7;
            border-radius: 6px;
            margin-bottom: 10px;
            font-size: 14px;
        }
        .chat-messages {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #ecf0f1;
            border-radius: 6px;
            padding: 15px;
            background: white;
            margin-top: 10px;
        }
        .message {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 6px;
        }
        .message.user {
            background: #e3f2fd;
            margin-left: 20px;
        }
        .message.ai {
            background: #f1f8e9;
            margin-right: 20px;
        }
        .message.system {
            background: #fff3e0;
            font-style: italic;
            text-align: center;
        }
        .pdf-list {
            background: white;
            border: 1px solid #ecf0f1;
            border-radius: 6px;
            padding: 15px;
            margin-top: 10px;
        }
        .pdf-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #ecf0f1;
        }
        .pdf-item:last-child {
            border-bottom: none;
        }
        .pdf-info {
            flex: 1;
        }
        .pdf-title {
            font-weight: bold;
            color: #2c3e50;
        }
        .pdf-meta {
            font-size: 12px;
            color: #7f8c8d;
        }
        .storage-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            margin-top: 10px;
        }
        .error {
            color: #e74c3c;
            background: #fdf2f2;
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
        }
        .success {
            color: #27ae60;
            background: #f0fff4;
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
        }
        .options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }
        .option-group {
            background: white;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #ecf0f1;
        }
        .option-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #34495e;
        }
        .option-group input,
        .option-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
        }
        .example-link {
            display: inline-block;
            background: #e8f4f8;
            color: #2c3e50;
            padding: 8px 12px;
            border-radius: 4px;
            text-decoration: none;
            margin-top: 10px;
            font-size: 12px;
        }
        .example-link:hover {
            background: #d4e9f1;
        }
        .schema-input {
            width: 100%;
            min-height: 120px;
            padding: 12px;
            border: 1px solid #bdc3c7;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            resize: vertical;
        }
        .process-result {
            background: white;
            border: 1px solid #ecf0f1;
            border-radius: 6px;
            padding: 15px;
            margin-top: 10px;
            max-height: 300px;
            overflow-y: auto;
        }
        .json-output {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .preset-buttons {
            margin-bottom: 10px;
        }
        .preset-buttons button {
            margin-right: 5px;
            margin-bottom: 5px;
            font-size: 12px;
            padding: 6px 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ§  WarpMind PDF Reader Demo</h1>
        
        <div class="section">
            <h2>ðŸ“„ Load PDF Document</h2>
            <p>Upload a PDF file or provide a URL to get started. The PDF will be processed to extract text and images, then indexed for semantic search.</p>
            
            <div class="file-input">
                <input type="file" id="pdfFile" accept=".pdf" />
            </div>
            
            <div class="url-input">
                <input type="url" id="pdfUrl" placeholder="Or enter PDF URL (e.g., https://example.com/document.pdf)" />
            </div>
            
            <div class="options">
                <div class="option-group">
                    <label for="chunkTokens">Chunk Size (tokens):</label>
                    <input type="number" id="chunkTokens" value="400" min="100" max="1000" />
                </div>
                <div class="option-group">
                    <label for="embedModel">Embedding Model:</label>
                    <select id="embedModel">
                        <option value="text-embedding-3-small">text-embedding-3-small</option>
                        <option value="text-embedding-3-large">text-embedding-3-large</option>
                        <option value="text-embedding-ada-002">text-embedding-ada-002</option>
                    </select>
                </div>
                <div class="option-group">
                    <label for="processImages">Process Images:</label>
                    <select id="processImages">
                        <option value="true">Yes</option>
                        <option value="false">No</option>
                    </select>
                </div>
                <div class="option-group">
                    <label for="imageDetail">Image Detail:</label>
                    <select id="imageDetail">
                        <option value="low">Low (faster, cheaper)</option>
                        <option value="high">High (slower, more expensive)</option>
                    </select>
                </div>
            </div>
            
            <button class="button" id="loadPdf">Load PDF</button>
            <button class="button" id="loadExamplePdf">Load Example PDF</button>
            
            <div class="progress-bar" id="progressBar" style="display: none;">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            
            <div id="loadStatus"></div>
            
            <a href="examples/instrumental_interaction.pdf" class="example-link" target="_blank">
                ðŸ“– View Example PDF (Instrumental Interaction)
            </a>
        </div>
        
        <div class="section">
            <h2>ðŸ’¬ Chat with PDF</h2>
            <p>Ask questions about the loaded PDF content. The AI will use semantic search to find relevant information.</p>
            
            <div class="chat-container">
                <input type="text" class="chat-input" id="chatInput" 
                       placeholder="Ask a question about the PDF (e.g., 'What is the main topic?', 'Describe the charts in section 3')" />
                <button class="button" id="sendMessage">Send</button>
                <button class="button" id="clearChat">Clear Chat</button>
                
                <div class="chat-messages" id="chatMessages">
                    <div class="message system">Load a PDF document first to start chatting</div>
                </div>
            </div>
        </div>
        
        <div class="section">
            <h2>ðŸ”§ Extract Structured Data</h2>
            <p>Use the process method to extract structured information from your PDF content. Define a schema and let AI extract the data automatically.</p>
            
            <div class="preset-buttons">
                <button class="button" onclick="loadPresetSchema('summary')">Document Summary</button>
                <button class="button" onclick="loadPresetSchema('research')">Research Paper</button>
                <button class="button" onclick="loadPresetSchema('authors')">Authors Only</button>
                <button class="button" onclick="loadPresetSchema('financial')">Financial Document</button>
                <button class="button" onclick="loadPresetSchema('contact')">Contact Information</button>
                <button class="button" onclick="loadPresetSchema('custom')">Clear Schema</button>
            </div>
            
            <div style="margin-bottom: 15px;">
                <label for="extractPrompt" style="display: block; margin-bottom: 5px; font-weight: bold;">Extraction Prompt:</label>
                <input type="text" id="extractPrompt" class="chat-input" 
                       placeholder="Describe what you want to extract (e.g., 'Extract key findings and methodology')" 
                       value="Extract the main information from this document" />
            </div>
            
            <div style="margin-bottom: 15px;">
                <label for="extractSchema" style="display: block; margin-bottom: 5px; font-weight: bold;">JSON Schema (define structure):</label>
                <textarea id="extractSchema" class="schema-input" 
                          placeholder="Enter JSON schema object defining the structure you want...">
{
  "title": "Document title",
  "authors": "Array of author names",
  "abstract": "Document abstract or summary",
  "keyFindings": "Array of key findings",
  "methodology": "Research methodology used",
  "conclusions": "Main conclusions"
}
                </textarea>
            </div>
            
            <button class="button" id="extractData" disabled>Extract Structured Data</button>
            <button class="button" onclick="clearProcessResult()">Clear Results</button>
            
            <div class="process-result" id="processResult" style="display: none;">
                <h3>Extracted Data:</h3>
                <div id="processOutput"></div>
            </div>
        </div>
        
        <div class="section">
            <h2>ðŸ“š PDF Library</h2>
            <p>Manage your loaded PDF documents and storage. Use the "Recall" button to load a PDF into memory and enable chat functionality. The currently loaded PDF is highlighted and marked as "Current".</p>
            
            <button class="button" id="refreshLibrary">Refresh Library</button>
            <button class="button" id="showStorage">Show Storage Info</button>
            
            <div class="pdf-list" id="pdfList">
                <div class="message system">No PDFs loaded yet</div>
            </div>
            
            <div class="storage-info" id="storageInfo" style="display: none;"></div>
        </div>
    </div>

    <!-- Load PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        // Configure PDF.js worker
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }
    </script>

    <!-- Load WarpMind -->
    <script src="../dist/warpmind.js?v=1.1.1"></script>
    
    <script>
        let mind;
        let currentPdfId = null;
        
        // Initialize WarpMind
        async function initWarpMind() {
            try {
                mind = new WarpMind({
                    // API key will be prompted automatically for real OpenAI API
                    // For demo, you can also set baseURL to a different endpoint
                    baseURL: 'https://warp.cs.au.dk/mind',
                    model: 'gpt-4o'
                });
                
                showMessage('WarpMind initialized successfully', 'success');
                updatePdfLibrary();
                updateExtractButton();
                
                // Load default preset
                loadPresetSchema('summary');
                
            } catch (error) {
                showMessage(`Failed to initialize WarpMind: ${error.message}`, 'error');
            }
        }
        
        // Show status message
        function showMessage(message, type = 'system') {
            const statusDiv = document.getElementById('loadStatus');
            statusDiv.innerHTML = `<div class="${type}">${message}</div>`;
            
            if (type === 'success' || type === 'error') {
                setTimeout(() => {
                    statusDiv.innerHTML = '';
                }, 5000);
            }
        }
        
        // Update progress bar
        function updateProgress(progress) {
            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            
            if (progress === 0) {
                progressBar.style.display = 'none';
            } else {
                progressBar.style.display = 'block';
                progressFill.style.width = `${progress * 100}%`;
                
                if (progress >= 1) {
                    setTimeout(() => {
                        progressBar.style.display = 'none';
                    }, 1000);
                }
            }
        }
        
        // Load PDF
        async function loadPdf(source) {
            if (!mind) {
                showMessage('Please initialize WarpMind first', 'error');
                return;
            }
            
            const options = {
                chunkTokens: parseInt(document.getElementById('chunkTokens').value),
                embedModel: document.getElementById('embedModel').value,
                processImages: document.getElementById('processImages').value === 'true',
                imageDetail: document.getElementById('imageDetail').value,
                onProgress: updateProgress
            };
            
            try {
                showMessage('Loading PDF...', 'system');
                updateProgress(0.05);
                
                const pdfId = await mind.readPdf(source, options);
                currentPdfId = pdfId;
                
                showMessage(`PDF loaded successfully! ID: ${pdfId}`, 'success');
                updateProgress(1);
                
                // Update UI
                updatePdfLibrary();
                enableChat();
                
            } catch (error) {
                showMessage(`Failed to load PDF: ${error.message}`, 'error');
                updateProgress(0);
            }
        }
        
        // Enable chat interface
        function enableChat() {
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.innerHTML = '<div class="message system">PDF loaded! Ask questions about the document.</div>';
            
            const chatInput = document.getElementById('chatInput');
            chatInput.disabled = false;
            chatInput.placeholder = 'Ask a question about the PDF...';
            
            // Enable extract button
            updateExtractButton();
        }
        
        // Send chat message
        async function sendMessage() {
            const chatInput = document.getElementById('chatInput');
            const message = chatInput.value.trim();
            
            if (!message || !mind || !currentPdfId) return;
            
            const chatMessages = document.getElementById('chatMessages');
            
            // Add user message
            const userMessage = document.createElement('div');
            userMessage.className = 'message user';
            userMessage.textContent = message;
            chatMessages.appendChild(userMessage);
            
            // Clear input
            chatInput.value = '';
            
            // Add thinking message
            const thinkingMessage = document.createElement('div');
            thinkingMessage.className = 'message system';
            thinkingMessage.textContent = 'AI is thinking...';
            chatMessages.appendChild(thinkingMessage);
            
            // Scroll to bottom
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            try {
                const response = await mind.chat(message);
                
                // Remove thinking message
                chatMessages.removeChild(thinkingMessage);
                
                // Add AI response
                const aiMessage = document.createElement('div');
                aiMessage.className = 'message ai';
                aiMessage.textContent = response;
                chatMessages.appendChild(aiMessage);
                
            } catch (error) {
                // Remove thinking message
                chatMessages.removeChild(thinkingMessage);
                
                // Add error message
                const errorMessage = document.createElement('div');
                errorMessage.className = 'message system';
                errorMessage.textContent = `Error: ${error.message}`;
                chatMessages.appendChild(errorMessage);
            }
            
            // Scroll to bottom
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        // Update PDF library
        async function updatePdfLibrary() {
            if (!mind) return;
            
            try {
                const pdfs = await mind.listReadPdfs();
                const pdfList = document.getElementById('pdfList');
                
                if (pdfs.length === 0) {
                    pdfList.innerHTML = '<div class="message system">No PDFs loaded yet</div>';
                    return;
                }
                
                pdfList.innerHTML = '';
                
                for (const pdf of pdfs) {
                    const pdfItem = document.createElement('div');
                    pdfItem.className = 'pdf-item';
                    
                    // Check if this PDF is currently selected
                    const isSelected = currentPdfId === pdf.id;
                    if (isSelected) {
                        pdfItem.style.backgroundColor = '#e8f4f8';
                        pdfItem.style.border = '1px solid #3498db';
                    }
                    
                    const pdfInfo = document.createElement('div');
                    pdfInfo.className = 'pdf-info';
                    pdfInfo.innerHTML = `
                        <div class="pdf-title">${pdf.title} ${isSelected ? '(Current)' : ''}</div>
                        <div class="pdf-meta">
                            ${pdf.numPages} pages â€¢ ${pdf.totalChunks} chunks â€¢ 
                            Processed: ${new Date(pdf.processedAt).toLocaleDateString()}
                        </div>
                    `;
                    
                    const pdfActions = document.createElement('div');
                    pdfActions.innerHTML = `
                        <button class="button" onclick="recallPdf('${pdf.id}')" ${isSelected ? 'disabled' : ''}>
                            ${isSelected ? 'Current' : 'Recall'}
                        </button>
                        <button class="button" onclick="forgetPdf('${pdf.id}')" style="background: #e74c3c;">
                            Forget
                        </button>
                    `;
                    
                    pdfItem.appendChild(pdfInfo);
                    pdfItem.appendChild(pdfActions);
                    pdfList.appendChild(pdfItem);
                }
                
            } catch (error) {
                console.error('Failed to update PDF library:', error);
            }
        }
        
        // Select PDF using recall
        async function selectPdf(pdfId) {
            if (!mind) {
                showMessage('WarpMind not initialized', 'error');
                return;
            }
            
            try {
                showMessage(`Loading PDF ${pdfId} into memory...`, 'system');
                
                // Use recall to load the PDF into memory and register its tools
                await mind.recall(pdfId);
                
                currentPdfId = pdfId;
                showMessage(`PDF ${pdfId} loaded and ready for chat`, 'success');
                enableChat();
                updatePdfLibrary(); // Update the UI to show the current PDF
                
            } catch (error) {
                showMessage(`Failed to load PDF ${pdfId}: ${error.message}`, 'error');
                console.error('PDF recall error:', error);
            }
        }
        
        // Recall PDF wrapper function for button events
        async function recallPdf(pdfId) {
            await selectPdf(pdfId);
        }
        
        // Forget PDF
        async function forgetPdf(pdfId) {
            if (!mind) return;
            
            if (confirm(`Are you sure you want to forget PDF "${pdfId}"? This will remove all cached data.`)) {
                try {
                    await mind.forgetPdf(pdfId);
                    showMessage(`PDF ${pdfId} forgotten`, 'success');
                    
                    if (currentPdfId === pdfId) {
                        currentPdfId = null;
                        const chatMessages = document.getElementById('chatMessages');
                        chatMessages.innerHTML = '<div class="message system">Load a PDF document first to start chatting</div>';
                        updateExtractButton();
                    }
                    
                    updatePdfLibrary();
                } catch (error) {
                    showMessage(`Failed to forget PDF: ${error.message}`, 'error');
                }
            }
        }
        
        // Show storage info
        async function showStorageInfo() {
            if (!mind) return;
            
            try {
                const storageInfo = await mind.getPdfStorageInfo();
                const storageDiv = document.getElementById('storageInfo');
                
                let html = `
                    <h3>Storage Information</h3>
                    <p><strong>Total Size:</strong> ${storageInfo.totalSize.toFixed(2)} ${storageInfo.unit}</p>
                    <h4>PDF Breakdown:</h4>
                `;
                
                if (storageInfo.pdfs.length === 0) {
                    html += '<p>No PDFs stored</p>';
                } else {
                    html += '<ul>';
                    for (const pdf of storageInfo.pdfs) {
                        html += `
                            <li>
                                <strong>${pdf.title}</strong>: ${pdf.size.toFixed(2)} MB 
                                (${pdf.chunks} chunks, processed ${new Date(pdf.processedAt).toLocaleDateString()})
                            </li>
                        `;
                    }
                    html += '</ul>';
                }
                
                storageDiv.innerHTML = html;
                storageDiv.style.display = 'block';
                
            } catch (error) {
                showMessage(`Failed to get storage info: ${error.message}`, 'error');
            }
        }
        
        // Clear chat
        function clearChat() {
            const chatMessages = document.getElementById('chatMessages');
            if (currentPdfId) {
                chatMessages.innerHTML = '<div class="message system">Chat cleared. PDF is still loaded.</div>';
            } else {
                chatMessages.innerHTML = '<div class="message system">Load a PDF document first to start chatting</div>';
            }
        }
        
        // Load preset schema
        function loadPresetSchema(type) {
            const promptInput = document.getElementById('extractPrompt');
            const schemaInput = document.getElementById('extractSchema');
            
            const presets = {
                summary: {
                    prompt: "Extract a comprehensive summary of this document",
                    schema: {
                        title: "Document title",
                        authors: "Array of author names",
                        abstract: "Document abstract or summary",
                        keyPoints: "Array of main points or findings",
                        conclusions: "Main conclusions",
                        documentType: "Type of document (research paper, report, etc.)"
                    }
                },
                research: {
                    prompt: "Extract research paper information and findings. Focus on the title page and first few paragraphs to identify document authors (not cited authors). Look for author names near the title, in headers, or with institutional affiliations.",
                    schema: {
                        title: "Research paper title from the title page",
                        authors: "Array of document authors from title page or header (not cited authors). Include first and last names only, no titles or affiliations",
                        authorAffiliations: "Array of institutional affiliations for the authors",
                        abstract: "Paper abstract from the beginning of the document",
                        researchQuestion: "Main research question or hypothesis",
                        methodology: "Research methodology used",
                        keyFindings: "Array of key findings from results section",
                        limitations: "Study limitations mentioned",
                        futureWork: "Suggestions for future research",
                        keywords: "Array of keywords if explicitly listed"
                    }
                },
                financial: {
                    prompt: "Extract financial information and key metrics",
                    schema: {
                        documentType: "Type of financial document",
                        period: "Time period covered",
                        revenue: "Revenue figures mentioned",
                        expenses: "Major expenses",
                        profit: "Profit/loss information",
                        keyMetrics: "Array of important financial metrics",
                        risks: "Risk factors mentioned",
                        outlook: "Future outlook or projections"
                    }
                },
                contact: {
                    prompt: "Extract contact information and organizational details",
                    schema: {
                        organizationName: "Organization or company name",
                        contactPersons: "Array of people mentioned with roles",
                        addresses: "Array of addresses",
                        phoneNumbers: "Array of phone numbers",
                        emails: "Array of email addresses",
                        websites: "Array of websites or URLs",
                        departments: "Array of departments mentioned"
                    }
                },
                authors: {
                    prompt: "Extract ONLY the document authors (not cited authors). Look specifically at the title page, header, or first page for names that appear with the document title or institutional affiliations. Ignore any names in references, citations, or bibliography sections.",
                    schema: {
                        title: "Document title from title page",
                        documentAuthors: "Array of document authors from title page/header - first and last names only, no titles",
                        authorInstitutions: "Array of institutional affiliations corresponding to each author",
                        correspondingAuthor: "Email or contact info for corresponding author if mentioned",
                        documentType: "Type of document (research paper, report, thesis, etc.)",
                        abstract: "Document abstract if present",
                        publicationInfo: "Journal name, conference, or publication venue if mentioned"
                    }
                },
                custom: {
                    prompt: "Extract the main information from this document",
                    schema: {
                        title: "Document title",
                        summary: "Brief summary",
                        keyInformation: "Array of key information points"
                    }
                }
            };
            
            const preset = presets[type];
            if (preset) {
                promptInput.value = preset.prompt;
                schemaInput.value = JSON.stringify(preset.schema, null, 2);
            }
        }
        
        // Extract structured data
        async function extractStructuredData() {
            if (!mind || !currentPdfId) {
                showMessage('Please load a PDF first', 'error');
                return;
            }
            
            const prompt = document.getElementById('extractPrompt').value.trim();
            const schemaText = document.getElementById('extractSchema').value.trim();
            
            if (!prompt || !schemaText) {
                showMessage('Please enter both a prompt and schema', 'error');
                return;
            }
            
            let schema;
            try {
                schema = JSON.parse(schemaText);
            } catch (error) {
                showMessage('Invalid JSON schema format', 'error');
                return;
            }
            
            const extractButton = document.getElementById('extractData');
            extractButton.disabled = true;
            extractButton.textContent = 'Extracting...';
            
            try {
                showMessage('Processing document and extracting structured data...', 'system');
                
                // For author extraction, get the first part of the document which typically contains metadata
                const isAuthorExtraction = JSON.stringify(schema).toLowerCase().includes('author');
                
                let pdfData;
                if (isAuthorExtraction) {
                    // Get first few chunks which typically contain title page and metadata
                    pdfData = await mind.chat(`Please use the search tool to find content from the beginning of PDF "${currentPdfId}" with query "title author abstract introduction" and return up to 4 chunks from the start of the document.`);
                } else {
                    // Get full PDF text for general processing
                    pdfData = await mind.chat(`Please use the full text tool to get the complete content of the PDF "${currentPdfId}".`);
                }
                
                // Enhanced prompt for author extraction
                let enhancedPrompt = prompt;
                if (isAuthorExtraction) {
                    enhancedPrompt += "\n\nIMPORTANT: Focus on the document's own authors (from title page/header), NOT authors mentioned in citations or references. Look for names that appear:\n- Near the document title\n- In the header or footer\n- With institutional affiliations\n- Before the abstract\nIgnore names in bibliography, citations, or reference lists.";
                }
                
                // Process the PDF data with the schema (without includeUsage to avoid API errors)
                const result = await mind.process(enhancedPrompt, pdfData, schema);
                
                // Display results
                displayProcessResult(result);
                
                showMessage('Structured data extracted successfully!', 'success');
                
            } catch (error) {
                showMessage(`Failed to extract data: ${error.message}`, 'error');
                console.error('Extraction error:', error);
            } finally {
                extractButton.disabled = false;
                extractButton.textContent = 'Extract Structured Data';
            }
        }
        
        // Display process result
        function displayProcessResult(result) {
            const processResult = document.getElementById('processResult');
            const processOutput = document.getElementById('processOutput');
            
            let html = '';
            
            if (result.data) {
                html += '<div class="json-output">' + JSON.stringify(result.data, null, 2) + '</div>';
            } else {
                html += '<div class="json-output">' + JSON.stringify(result, null, 2) + '</div>';
            }
            
            if (result.usage) {
                html += `
                    <div style="margin-top: 10px; padding: 10px; background: #f0f8ff; border-radius: 4px; font-size: 12px;">
                        <strong>Token Usage:</strong> 
                        Prompt: ${result.usage.prompt_tokens || 0}, 
                        Completion: ${result.usage.completion_tokens || 0}, 
                        Total: ${result.usage.total_tokens || 0}
                    </div>
                `;
            } else {
                html += `
                    <div style="margin-top: 10px; padding: 10px; background: #fff3cd; border-radius: 4px; font-size: 12px; color: #856404;">
                        <strong>Note:</strong> Token usage information not available for this API endpoint.
                    </div>
                `;
            }
            
            processOutput.innerHTML = html;
            processResult.style.display = 'block';
        }
        
        // Clear process result
        function clearProcessResult() {
            const processResult = document.getElementById('processResult');
            processResult.style.display = 'none';
        }
        
        // Update extract button state
        function updateExtractButton() {
            const extractButton = document.getElementById('extractData');
            extractButton.disabled = !currentPdfId;
        }
        
        // Event listeners
        document.getElementById('loadPdf').addEventListener('click', () => {
            const fileInput = document.getElementById('pdfFile');
            const urlInput = document.getElementById('pdfUrl');
            
            if (fileInput.files[0]) {
                loadPdf(fileInput.files[0]);
            } else if (urlInput.value.trim()) {
                loadPdf(urlInput.value.trim());
            } else {
                showMessage('Please select a file or enter a URL', 'error');
            }
        });
        
        document.getElementById('loadExamplePdf').addEventListener('click', () => {
            loadPdf('examples/instrumental_interaction.pdf');
        });
        
        document.getElementById('sendMessage').addEventListener('click', sendMessage);
        
        document.getElementById('chatInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });
        
        document.getElementById('clearChat').addEventListener('click', clearChat);
        
        document.getElementById('refreshLibrary').addEventListener('click', updatePdfLibrary);
        
        document.getElementById('showStorage').addEventListener('click', showStorageInfo);
        
        document.getElementById('extractData').addEventListener('click', extractStructuredData);
        
        // Initialize on page load
        window.addEventListener('load', initWarpMind);
    </script>
</body>
</html>
