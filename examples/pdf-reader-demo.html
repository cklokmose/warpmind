<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WarpMind PDF Reader Demo</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            margin-bottom: 30px;
            text-align: center;
        }
        .section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }
        .section h2 {
            color: #34495e;
            margin-top: 0;
        }
        .file-input {
            margin-bottom: 15px;
        }
        .file-input input[type="file"] {
            width: 100%;
            padding: 10px;
            border: 2px dashed #bdc3c7;
            border-radius: 6px;
            background: white;
        }
        .url-input {
            margin-bottom: 15px;
        }
        .url-input input[type="url"] {
            width: 100%;
            padding: 12px;
            border: 1px solid #bdc3c7;
            border-radius: 6px;
            font-size: 14px;
        }
        .button {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        .button:hover {
            background: #2980b9;
        }
        .button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }
        .progress-container {
            margin: 20px 0;
            background: #f1f1f1;
            border-radius: 5px;
            height: 25px;
            position: relative;
            overflow: hidden;
            display: none;
        }
        .progress-bar {
            background: #4CAF50;
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
        }
        .progress-text {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #333;
            font-size: 0.9em;
            font-weight: 500;
            text-shadow: 0 0 2px rgba(255,255,255,0.7);
        }
        .slow-response {
            color: #d35400;
            animation: pulse 2s infinite;
            font-weight: 600;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        .chat-container {
            margin-top: 20px;
        }
        .chat-input {
            width: 100%;
            padding: 12px;
            border: 1px solid #bdc3c7;
            border-radius: 6px;
            margin-bottom: 10px;
            font-size: 14px;
        }
        .chat-messages {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #ecf0f1;
            border-radius: 6px;
            padding: 15px;
            background: white;
            margin-top: 10px;
        }
        .message {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 6px;
        }
        .message.user {
            background: #e3f2fd;
            margin-left: 20px;
        }
        .message.ai {
            background: #f1f8e9;
            margin-right: 20px;
        }
        .message.system {
            background: #fff3e0;
            font-style: italic;
            text-align: center;
        }
        .pdf-list {
            background: white;
            border: 1px solid #ecf0f1;
            border-radius: 6px;
            padding: 15px;
            margin-top: 10px;
        }
        .pdf-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #ecf0f1;
        }
        .pdf-item:last-child {
            border-bottom: none;
        }
        .pdf-info {
            flex: 1;
        }
        .pdf-title {
            font-weight: bold;
            color: #2c3e50;
        }
        .pdf-meta {
            font-size: 12px;
            color: #7f8c8d;
        }
        .storage-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            margin-top: 10px;
        }
        .error {
            color: #e74c3c;
            background: #fdf2f2;
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
        }
        .success {
            color: #27ae60;
            background: #f0fff4;
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
        }
        .warning {
            color: #f39c12;
            background: #fff8e1;
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
            border-left: 4px solid #f39c12;
        }
        .options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }
        .option-group {
            background: white;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #ecf0f1;
        }
        .option-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #34495e;
        }
        .option-group input,
        .option-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
        }
        .example-link {
            display: inline-block;
            background: #e8f4f8;
            color: #2c3e50;
            padding: 8px 12px;
            border-radius: 4px;
            text-decoration: none;
            margin-top: 10px;
            font-size: 12px;
        }
        .example-link:hover {
            background: #d4e9f1;
        }
        .schema-input {
            width: 100%;
            min-height: 120px;
            padding: 12px;
            border: 1px solid #bdc3c7;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            resize: vertical;
        }
        .process-result {
            background: white;
            border: 1px solid #ecf0f1;
            border-radius: 6px;
            padding: 15px;
            margin-top: 10px;
            max-height: 300px;
            overflow-y: auto;
        }
        .json-output {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .preset-buttons {
            margin-bottom: 10px;
        }
        .preset-buttons button {
            margin-right: 5px;
            margin-bottom: 5px;
            font-size: 12px;
            padding: 6px 12px;
        }
        .page-range-input {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        .page-range-input input {
            width: 70px !important;
            text-align: center;
        }
        .page-range-help {
            color: #666;
            font-size: 11px;
            margin-top: 3px;
        }
        .limit-warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 12px;
            border-radius: 6px;
            margin: 15px 0;
            font-size: 13px;
        }
        .limit-warning strong {
            color: #b7950b;
        }
        
        /* Configuration status styles */
        .config-success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        .config-error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }
        .config-info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß† WarpMind PDF Reader Demo</h1>
        
        <!-- API Configuration Section -->
        <div class="section">
            <h2>üîë API Configuration</h2>
            <div class="option-group">
                <label for="serverURL">Server Endpoint:</label>
                <input type="url" id="serverURL" placeholder="https://warp.cs.au.dk/mind" value="https://warp.cs.au.dk/mind" />
                <small style="color: #6c757d; font-size: 12px; margin-top: 5px; display: block;">
                    Enter the base URL for your WarpMind-compatible API endpoint
                </small>
            </div>
            <div class="option-group">
                <label for="apiKey">API Key (Optional):</label>
                <input type="password" id="apiKey" placeholder="Enter your API key (leave empty for automatic prompting)" />
                <small style="color: #6c757d; font-size: 12px; margin-top: 5px; display: block;">
                    If no API key is provided, you will be prompted automatically when needed
                </small>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 15px;">
                <button id="initializeBtn" class="button">
                    üöÄ Initialize WarpMind
                </button>
                <button id="resetConfigBtn" class="button" style="background: #6c757d;">
                    üîÑ Reset to Defaults
                </button>
            </div>
            <div id="configStatus" style="margin-top: 10px; padding: 10px; border-radius: 6px; display: none;"></div>
        </div>
        
        <div class="section">
            <h2>üìÑ Load PDF Document</h2>
            <p>Upload a PDF file or provide a URL to get started. The PDF will be processed to extract text and indexed for semantic search.</p>
            <p><strong>New:</strong> PDFs are limited to 100 pages maximum. For larger documents, use the page range option to process specific sections.</p>
            
            <div class="file-input">
                <input type="file" id="pdfFile" accept=".pdf" />
            </div>
            
            <div class="url-input">
                <input type="url" id="pdfUrl" placeholder="Or enter PDF URL (e.g., https://example.com/document.pdf)" />
            </div>
            
            <div class="options">
                <div class="option-group">
                    <label for="chunkTokens">Chunk Size (tokens):</label>
                    <input type="number" id="chunkTokens" value="400" min="100" max="1000" />
                </div>
                <div class="option-group">
                    <label for="embedModel">Embedding Model:</label>
                    <select id="embedModel">
                        <option value="text-embedding-3-small">text-embedding-3-small</option>
                        <option value="text-embedding-3-large">text-embedding-3-large</option>
                        <option value="text-embedding-ada-002">text-embedding-ada-002</option>
                    </select>
                </div>
                <div class="option-group">
                    <label for="pageRangeStart">Page Range (optional):</label>
                    <div class="page-range-input">
                        <input type="number" id="pageRangeStart" placeholder="Start" min="1" />
                        <span>to</span>
                        <input type="number" id="pageRangeEnd" placeholder="End" min="1" />
                    </div>
                    <div class="page-range-help">
                        Max 100 pages total. Leave empty to process full document.<br>
                        <button class="button" onclick="setPageRange(1, 10)" style="font-size: 10px; padding: 2px 6px; margin: 2px;">1-10</button>
                        <button class="button" onclick="setPageRange(1, 25)" style="font-size: 10px; padding: 2px 6px; margin: 2px;">1-25</button>
                        <button class="button" onclick="setPageRange(1, 50)" style="font-size: 10px; padding: 2px 6px; margin: 2px;">1-50</button>
                        <button class="button" onclick="setPageRange(1, 100)" style="font-size: 10px; padding: 2px 6px; margin: 2px;">1-100</button>
                    </div>
                </div>
            </div>
            
            <div class="limit-warning">
                ‚ö†Ô∏è <strong>Page Limit:</strong> PDFs are limited to 100 pages maximum to prevent excessive processing costs. 
                For larger documents, specify a page range above to process only the needed sections.
            </div>
            
            <button class="button" id="loadPdf">Load PDF</button>
            <button class="button" id="loadExamplePdf">Load Example PDF</button>
            <button class="button" id="clearRange" style="background: #95a5a6;">Clear Range</button>
            
            <div class="progress-container" id="progressBar" style="display: none;">
                <div class="progress-bar" id="progressFill"></div>
                <div class="progress-text" id="progressText"></div>
            </div>
            
            <div id="loadStatus"></div>
            
            <a href="examples/instrumental_interaction.pdf" class="example-link" target="_blank">
                üìñ View Example PDF (Instrumental Interaction)
            </a>
        </div>
        
        <div class="section">
            <h2>üí¨ Chat with PDF</h2>
            <p>Ask questions about the loaded PDF content. The AI will use semantic search to find relevant information.</p>
            
            <div class="chat-container">
                <input type="text" class="chat-input" id="chatInput" 
                       placeholder="Ask a question about the PDF (e.g., 'What is the main topic?', 'Summarize the key findings')" />
                <button class="button" id="sendMessage">Send</button>
                <button class="button" id="clearChat">Clear Chat</button>
                
                <div class="chat-messages" id="chatMessages">
                    <div class="message system">Load a PDF document first to start chatting</div>
                </div>
            </div>
        </div>
        
        <div class="section">
            <h2>üîß Extract Structured Data</h2>
            <p>Use the streamlined <code>process("prompt", "pdf", schema)</code> method to extract structured information directly from your PDF content. Define a schema and let AI extract the data automatically using the optimized PDF processing approach.</p>
            
            <div class="preset-buttons">
                <button class="button" onclick="loadPresetSchema('summary')">Document Summary</button>
                <button class="button" onclick="loadPresetSchema('research')">Research Paper</button>
                <button class="button" onclick="loadPresetSchema('authors')">Authors Only</button>
                <button class="button" onclick="loadPresetSchema('financial')">Financial Document</button>
                <button class="button" onclick="loadPresetSchema('contact')">Contact Information</button>
                <button class="button" onclick="loadPresetSchema('custom')">Clear Schema</button>
            </div>
            
            <div style="margin-bottom: 15px;">
                <label for="extractPrompt" style="display: block; margin-bottom: 5px; font-weight: bold;">Extraction Prompt:</label>
                <input type="text" id="extractPrompt" class="chat-input" 
                       placeholder="Describe what you want to extract (e.g., 'Extract key findings and methodology')" 
                       value="Extract the main information from this document" />
            </div>
            
            <div style="margin-bottom: 15px;">
                <label for="extractSchema" style="display: block; margin-bottom: 5px; font-weight: bold;">JSON Schema (define structure):</label>
                <textarea id="extractSchema" class="schema-input" 
                          placeholder="Enter JSON schema object defining the structure you want...">
{
  "title": "Document title",
  "authors": "Array of author names",
  "abstract": "Document abstract or summary",
  "keyFindings": "Array of key findings",
  "methodology": "Research methodology used",
  "conclusions": "Main conclusions"
}
                </textarea>
            </div>
            
            <button class="button" id="extractData" disabled>Extract Structured Data</button>
            <button class="button" onclick="clearProcessResult()">Clear Results</button>
            
            <div class="process-result" id="processResult" style="display: none;">
                <h3>Extracted Data:</h3>
                <div id="processOutput"></div>
            </div>
        </div>
        
        <div class="section">
            <h2>üìö PDF Library</h2>
            <p>Manage your loaded PDF documents and storage. Use the "Recall" button to load a PDF into memory and enable chat functionality. The currently loaded PDF is highlighted and marked as "Current".</p>
            
            <button class="button" id="refreshLibrary">Refresh Library</button>
            <button class="button" id="showStorage">Show Storage Info</button>
            
            <div class="pdf-list" id="pdfList">
                <div class="message system">No PDFs loaded yet</div>
            </div>
            
            <div class="storage-info" id="storageInfo" style="display: none;"></div>
        </div>

        <div class="section">
            <h2>üì¶ Export/Import PDFs</h2>
            <p>Save PDF processing time and tokens by exporting processed PDFs with embeddings. Share these files with students to avoid re-processing the same documents.</p>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                <div>
                    <h3>üì§ Export PDF</h3>
                    <p>Export a processed PDF with all embeddings and metadata as a ZIP file.</p>
                    <select id="exportPdfSelect" class="input" style="margin-bottom: 10px;">
                        <option value="">Select PDF to export...</option>
                    </select>
                    <button class="button" id="exportPdfBtn" disabled>Export PDF</button>
                </div>
                
                <div>
                    <h3>üì• Import PDF</h3>
                    <p>Import a previously exported PDF file to instantly have it available with embeddings.</p>
                    <input type="file" id="importPdfFile" accept=".zip" style="margin-bottom: 10px;" />
                    <button class="button" id="importPdfBtn" disabled>Import PDF</button>
                    <div>
                        <label style="font-size: 12px;">
                            <input type="checkbox" id="overwriteExisting" /> Overwrite if PDF already exists
                        </label>
                    </div>
                </div>
            </div>
            
            <div class="progress-container" id="exportImportProgress" style="display: none;">
                <div class="progress-bar" id="exportImportProgressFill"></div>
                <div class="progress-text" id="exportImportProgressText"></div>
            </div>
            
            <div id="exportImportStatus"></div>
        </div>
    </div>

    <!-- Load PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        // Configure PDF.js worker
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }
    </script>

    <!-- Load WarpMind -->
    <script src="../dist/warpmind.js?v=1.1.1"></script>
    
    <script>
        let mind;
        let currentPdfId = null;
        
        // Configuration management
        const DEFAULT_CONFIG = {
            baseURL: 'https://warp.cs.au.dk/mind',
            model: 'gpt-4o'
        };

        // Load configuration from localStorage or use defaults
        function loadConfiguration() {
            const savedConfig = localStorage.getItem('warpMind-pdf-demo-config');
            if (savedConfig) {
                try {
                    return JSON.parse(savedConfig);
                } catch (e) {
                    console.warn('Failed to parse saved config, using defaults');
                    return DEFAULT_CONFIG;
                }
            }
            return DEFAULT_CONFIG;
        }

        // Save configuration to localStorage
        function saveConfiguration(config) {
            localStorage.setItem('warpMind-pdf-demo-config', JSON.stringify(config));
        }

        // Show configuration status message
        function showConfigStatus(message, type) {
            const statusDiv = document.getElementById('configStatus');
            statusDiv.style.display = 'block';
            statusDiv.className = `config-${type}`;
            statusDiv.textContent = message;
            
            // Hide after 3 seconds unless it's an error
            if (type !== 'error') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 3000);
            }
        }

        // Initialize configuration form
        function initializeForm() {
            const savedConfig = loadConfiguration();
            document.getElementById('serverURL').value = savedConfig.baseURL || DEFAULT_CONFIG.baseURL;
            document.getElementById('apiKey').value = savedConfig.apiKey || '';
        }

        // Reset configuration to defaults
        function resetConfiguration() {
            document.getElementById('serverURL').value = DEFAULT_CONFIG.baseURL;
            document.getElementById('apiKey').value = '';
            
            saveConfiguration(DEFAULT_CONFIG);
            showConfigStatus('Configuration reset to defaults', 'info');
        }
        
        // Initialize WarpMind with configuration
        async function initWarpMind() {
            try {
                const serverURL = document.getElementById('serverURL').value.trim();
                const apiKey = document.getElementById('apiKey').value.trim();
                
                if (!serverURL) {
                    showConfigStatus('Please enter a server URL', 'error');
                    return;
                }

                // Build configuration object
                const config = {
                    ...DEFAULT_CONFIG,
                    baseURL: serverURL
                };
                
                if (apiKey) {
                    config.apiKey = apiKey;
                }

                // Save configuration
                saveConfiguration(config);
                
                // Initialize WarpMind
                mind = new WarpMind(config);

                showConfigStatus('WarpMind initialized successfully!', 'success');
                showMessage('WarpMind initialized successfully', 'success');
                
                if (apiKey) {
                    showMessage(`Using server: ${serverURL} with provided API key`, 'info');
                } else {
                    showMessage(`Using server: ${serverURL} - will prompt for API key when needed`, 'info');
                }
                
                updatePdfLibrary();
                updateExtractButton();
                
                // Load default preset
                loadPresetSchema('summary');
                
            } catch (error) {
                showMessage(`Failed to initialize WarpMind: ${error.message}`, 'error');
            }
        }
        
        // Show status message
        function showMessage(message, type = 'system') {
            const statusDiv = document.getElementById('loadStatus');
            statusDiv.innerHTML = `<div class="${type}">${message}</div>`;
            
            if (type === 'success' || type === 'error') {
                setTimeout(() => {
                    statusDiv.innerHTML = '';
                }, 5000);
            }
        }
        
        // Update progress bar
        function updateProgress(progress, description) {
            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            
            if (progress === 0) {
                progressBar.style.display = 'none';
                progressText.textContent = '';
            } else {
                progressBar.style.display = 'block';
                progressFill.style.width = `${progress * 100}%`;
                
                // Display description if available
                if (description) {
                    progressText.textContent = description;
                    
                    // Highlight slow backend responses
                    if (description.includes('waiting for backend') || description.includes('backend response')) {
                        progressText.classList.add('slow-response');
                    } else {
                        progressText.classList.remove('slow-response');
                    }
                }
                
                if (progress >= 1) {
                    setTimeout(() => {
                        progressBar.style.display = 'none';
                        progressText.textContent = '';
                    }, 1000);
                }
            }
        }
        
        // Load PDF
        async function loadPdf(source) {
            if (!mind) {
                showMessage('Please initialize WarpMind first', 'error');
                return;
            }
            
            const options = {
                chunkTokens: parseInt(document.getElementById('chunkTokens').value),
                embedModel: document.getElementById('embedModel').value,
                onProgress: (progress, description) => updateProgress(progress, description)
            };
            
            // Add page range if specified
            const startPage = parseInt(document.getElementById('pageRangeStart').value);
            const endPage = parseInt(document.getElementById('pageRangeEnd').value);
            
            if (startPage && endPage) {
                options.pageRange = [startPage, endPage];
                showMessage(`Loading pages ${startPage}-${endPage}...`, 'system');
            } else if (startPage || endPage) {
                showMessage('Please specify both start and end page, or leave both empty for full document', 'error');
                return;
            }
            
            try {
                showMessage('Loading PDF...', 'system');
                updateProgress(0.05);
                
                // Set up a long operation warning
                let isLongOperation = false;
                const longOperationTimeout = setTimeout(() => {
                    isLongOperation = true;
                    showMessage('PDF processing is taking longer than expected. This is normal for large or complex documents, and for slower backend responses.', 'warning');
                }, 15000); // Show warning after 15 seconds
                
                const pdfId = await mind.readPdf(source, options);
                clearTimeout(longOperationTimeout);
                currentPdfId = pdfId;
                
                if (isLongOperation) {
                    showMessage(`PDF loaded successfully after extended processing! ID: ${pdfId}`, 'success');
                } else {
                    showMessage(`PDF loaded successfully! ID: ${pdfId}`, 'success');
                }
                updateProgress(1);
                
                // Update UI
                updatePdfLibrary();
                enableChat();
                
            } catch (error) {
                showMessage(`Failed to load PDF: ${error.message}`, 'error');
                updateProgress(0);
            }
        }
        
        // Enable chat interface
        function enableChat() {
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.innerHTML = '<div class="message system">PDF loaded! Ask questions about the document.</div>';
            
            const chatInput = document.getElementById('chatInput');
            chatInput.disabled = false;
            chatInput.placeholder = 'Ask a question about the PDF...';
            
            // Enable extract button
            updateExtractButton();
        }
        
        // Send chat message
        async function sendMessage() {
            const chatInput = document.getElementById('chatInput');
            const message = chatInput.value.trim();
            
            if (!message || !mind || !currentPdfId) return;
            
            const chatMessages = document.getElementById('chatMessages');
            
            // Add user message
            const userMessage = document.createElement('div');
            userMessage.className = 'message user';
            userMessage.textContent = message;
            chatMessages.appendChild(userMessage);
            
            // Clear input
            chatInput.value = '';
            
            // Add thinking message
            const thinkingMessage = document.createElement('div');
            thinkingMessage.className = 'message system';
            thinkingMessage.textContent = 'AI is thinking...';
            chatMessages.appendChild(thinkingMessage);
            
            // Scroll to bottom
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            try {
                const response = await mind.chat(message);
                
                // Remove thinking message
                chatMessages.removeChild(thinkingMessage);
                
                // Add AI response
                const aiMessage = document.createElement('div');
                aiMessage.className = 'message ai';
                aiMessage.textContent = response;
                chatMessages.appendChild(aiMessage);
                
            } catch (error) {
                // Remove thinking message
                chatMessages.removeChild(thinkingMessage);
                
                // Add error message
                const errorMessage = document.createElement('div');
                errorMessage.className = 'message system';
                errorMessage.textContent = `Error: ${error.message}`;
                chatMessages.appendChild(errorMessage);
            }
            
            // Scroll to bottom
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        // Update PDF library
        async function updatePdfLibrary() {
            if (!mind) return;
            
            try {
                const pdfs = await mind.listReadPdfs();
                const pdfList = document.getElementById('pdfList');
                
                if (pdfs.length === 0) {
                    pdfList.innerHTML = '<div class="message system">No PDFs loaded yet</div>';
                    // Also update export dropdown when no PDFs
                    await updateExportDropdown();
                    return;
                }
                
                pdfList.innerHTML = '';
                
                for (const pdf of pdfs) {
                    const pdfItem = document.createElement('div');
                    pdfItem.className = 'pdf-item';
                    
                    // Check if this PDF is currently selected
                    const isSelected = currentPdfId === pdf.id;
                    if (isSelected) {
                        pdfItem.style.backgroundColor = '#e8f4f8';
                        pdfItem.style.border = '1px solid #3498db';
                    }
                    
                    const pdfInfo = document.createElement('div');
                    pdfInfo.className = 'pdf-info';
                    
                    let pageInfo = `${pdf.numPages} total pages`;
                    if (pdf.pageRange) {
                        pageInfo += ` ‚Ä¢ Processed: ${pdf.pageRange.start}-${pdf.pageRange.end} (${pdf.pagesProcessed} pages)`;
                    } else {
                        pageInfo += ` ‚Ä¢ ${pdf.pagesProcessed || pdf.numPages} processed`;
                    }
                    
                    pdfInfo.innerHTML = `
                        <div class="pdf-title">${pdf.title} ${isSelected ? '(Current)' : ''}</div>
                        <div class="pdf-meta">
                            ${pageInfo} ‚Ä¢ ${pdf.totalChunks} chunks ‚Ä¢ 
                            Processed: ${new Date(pdf.processedAt).toLocaleDateString()}
                        </div>
                    `;
                    
                    const pdfActions = document.createElement('div');
                    pdfActions.innerHTML = `
                        <button class="button" onclick="recallPdf('${pdf.id}')" ${isSelected ? 'disabled' : ''}>
                            ${isSelected ? 'Current' : 'Recall'}
                        </button>
                        <button class="button" onclick="forgetPdf('${pdf.id}')" style="background: #e74c3c;">
                            Forget
                        </button>
                    `;
                    
                    pdfItem.appendChild(pdfInfo);
                    pdfItem.appendChild(pdfActions);
                    pdfList.appendChild(pdfItem);
                }
                
                // Also update export dropdown
                await updateExportDropdown();
                
            } catch (error) {
                console.error('Failed to update PDF library:', error);
            }
        }
        
        // Update export PDF dropdown
        async function updateExportDropdown() {
            if (!mind) return;
            
            try {
                const pdfs = await mind.listReadPdfs();
                const exportSelect = document.getElementById('exportPdfSelect');
                
                exportSelect.innerHTML = '<option value="">Select PDF to export...</option>';
                
                for (const pdf of pdfs) {
                    const option = document.createElement('option');
                    option.value = pdf.id;
                    option.textContent = `${pdf.title} (${pdf.totalChunks} chunks)`;
                    exportSelect.appendChild(option);
                }
                
                // Enable export button if PDFs are available
                document.getElementById('exportPdfBtn').disabled = pdfs.length === 0;
                
            } catch (error) {
                console.error('Failed to update export dropdown:', error);
            }
        }
        
        // Export PDF function
        async function exportPdf() {
            const pdfId = document.getElementById('exportPdfSelect').value;
            if (!pdfId || !mind) return;
            
            try {
                showExportImportProgress(0, 'Starting export...');
                
                showMessage('Exporting PDF with embeddings...', 'system');
                
                const exportResult = await mind.exportPdf(pdfId);
                
                showExportImportProgress(100, 'Export complete!');
                
                // Create download link
                const url = URL.createObjectURL(exportResult.blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = exportResult.fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showMessage(`PDF exported: ${exportResult.fileName} (${(exportResult.size / 1024 / 1024).toFixed(2)} MB)`, 'success');
                
                setTimeout(() => hideExportImportProgress(), 2000);
                
            } catch (error) {
                console.error('Export failed:', error);
                showMessage(`Export failed: ${error.message}`, 'error');
                hideExportImportProgress();
            }
        }
        
        // Import PDF function
        async function importPdf() {
            const fileInput = document.getElementById('importPdfFile');
            const file = fileInput.files[0];
            const overwrite = document.getElementById('overwriteExisting').checked;
            
            if (!file) {
                showMessage('Please select a ZIP file to import', 'error');
                return;
            }
            
            if (!mind) {
                showMessage('Please initialize WarpMind first (set endpoint and API key)', 'error');
                return;
            }
            
            try {
                showExportImportProgress(0, 'Starting import...');
                
                showMessage('Importing PDF...', 'system');
                
                const importResult = await mind.importPdf(file, {
                    overwrite: overwrite,
                    onProgress: (progress, message) => {
                        showExportImportProgress(progress, message);
                    }
                });
                
                showExportImportProgress(100, 'Import complete!');
                
                showMessage(`PDF imported: ${importResult.title} (${importResult.chunks} chunks, ${importResult.pages} pages)`, 'success');
                
                // Update library and export dropdown
                await updatePdfLibrary();
                await updateExportDropdown();
                
                // Clear file input
                fileInput.value = '';
                
                setTimeout(() => hideExportImportProgress(), 2000);
                
            } catch (error) {
                console.error('Import failed:', error);
                showMessage(`Import failed: ${error.message}`, 'error');
                hideExportImportProgress();
            }
        }
        
        // Show export/import progress
        function showExportImportProgress(progress, text) {
            const progressContainer = document.getElementById('exportImportProgress');
            const progressFill = document.getElementById('exportImportProgressFill');
            const progressText = document.getElementById('exportImportProgressText');
            
            progressContainer.style.display = 'block';
            progressFill.style.width = `${Math.min(progress, 100)}%`;
            progressText.textContent = text;
        }
        
        // Hide export/import progress
        function hideExportImportProgress() {
            const progressContainer = document.getElementById('exportImportProgress');
            progressContainer.style.display = 'none';
        }
        
        // Select PDF using recall
        async function selectPdf(pdfId) {
            if (!mind) {
                showMessage('WarpMind not initialized', 'error');
                return;
            }
            
            try {
                showMessage(`Loading PDF ${pdfId} into memory...`, 'system');
                
                // Use recallPdf to load the PDF into memory and register its tools
                await mind.recallPdf(pdfId);
                
                currentPdfId = pdfId;
                showMessage(`PDF ${pdfId} loaded and ready for chat`, 'success');
                enableChat();
                updatePdfLibrary(); // Update the UI to show the current PDF
                
            } catch (error) {
                showMessage(`Failed to load PDF ${pdfId}: ${error.message}`, 'error');
                console.error('PDF recall error:', error);
            }
        }
        
        // Recall PDF wrapper function for button events
        async function recallPdf(pdfId) {
            await selectPdf(pdfId);
        }
        
        // Forget PDF
        async function forgetPdf(pdfId) {
            if (!mind) return;
            
            if (confirm(`Are you sure you want to forget PDF "${pdfId}"? This will remove all cached data.`)) {
                try {
                    await mind.forgetPdf(pdfId);
                    showMessage(`PDF ${pdfId} forgotten`, 'success');
                    
                    if (currentPdfId === pdfId) {
                        currentPdfId = null;
                        const chatMessages = document.getElementById('chatMessages');
                        chatMessages.innerHTML = '<div class="message system">Load a PDF document first to start chatting</div>';
                        updateExtractButton();
                    }
                    
                    updatePdfLibrary();
                } catch (error) {
                    showMessage(`Failed to forget PDF: ${error.message}`, 'error');
                }
            }
        }
        
        // Show storage info
        async function showStorageInfo() {
            if (!mind) return;
            
            try {
                const storageInfo = await mind.getPdfStorageInfo();
                const storageDiv = document.getElementById('storageInfo');
                
                let html = `
                    <h3>Storage Information</h3>
                    <p><strong>Total Size:</strong> ${storageInfo.totalSize.toFixed(2)} ${storageInfo.unit}</p>
                    <h4>PDF Breakdown:</h4>
                `;
                
                if (storageInfo.pdfs.length === 0) {
                    html += '<p>No PDFs stored</p>';
                } else {
                    html += '<ul>';
                    for (const pdf of storageInfo.pdfs) {
                        html += `
                            <li>
                                <strong>${pdf.title}</strong>: ${pdf.size.toFixed(2)} MB 
                                (${pdf.chunks} chunks, processed ${new Date(pdf.processedAt).toLocaleDateString()})
                            </li>
                        `;
                    }
                    html += '</ul>';
                }
                
                storageDiv.innerHTML = html;
                storageDiv.style.display = 'block';
                
            } catch (error) {
                showMessage(`Failed to get storage info: ${error.message}`, 'error');
            }
        }
        
        // Clear chat
        function clearChat() {
            const chatMessages = document.getElementById('chatMessages');
            if (currentPdfId) {
                chatMessages.innerHTML = '<div class="message system">Chat cleared. PDF is still loaded.</div>';
            } else {
                chatMessages.innerHTML = '<div class="message system">Load a PDF document first to start chatting</div>';
            }
        }
        
        // Load preset schema
        function loadPresetSchema(type) {
            const promptInput = document.getElementById('extractPrompt');
            const schemaInput = document.getElementById('extractSchema');
            
            const presets = {
                summary: {
                    prompt: "Extract a comprehensive summary of this document",
                    schema: {
                        title: "Document title",
                        authors: "Array of author names",
                        abstract: "Document abstract or summary",
                        keyPoints: "Array of main points or findings",
                        conclusions: "Main conclusions",
                        documentType: "Type of document (research paper, report, etc.)"
                    }
                },
                research: {
                    prompt: "Extract research paper information and findings. Focus on the title page and first few paragraphs to identify document authors (not cited authors). Look for author names near the title, in headers, or with institutional affiliations.",
                    schema: {
                        title: "Research paper title from the title page",
                        authors: "Array of document authors from title page or header (not cited authors). Include first and last names only, no titles or affiliations",
                        authorAffiliations: "Array of institutional affiliations for the authors",
                        abstract: "Paper abstract from the beginning of the document",
                        researchQuestion: "Main research question or hypothesis",
                        methodology: "Research methodology used",
                        keyFindings: "Array of key findings from results section",
                        limitations: "Study limitations mentioned",
                        futureWork: "Suggestions for future research",
                        keywords: "Array of keywords if explicitly listed"
                    }
                },
                financial: {
                    prompt: "Extract financial information and key metrics",
                    schema: {
                        documentType: "Type of financial document",
                        period: "Time period covered",
                        revenue: "Revenue figures mentioned",
                        expenses: "Major expenses",
                        profit: "Profit/loss information",
                        keyMetrics: "Array of important financial metrics",
                        risks: "Risk factors mentioned",
                        outlook: "Future outlook or projections"
                    }
                },
                contact: {
                    prompt: "Extract contact information and organizational details",
                    schema: {
                        organizationName: "Organization or company name",
                        contactPersons: "Array of people mentioned with roles",
                        addresses: "Array of addresses",
                        phoneNumbers: "Array of phone numbers",
                        emails: "Array of email addresses",
                        websites: "Array of websites or URLs",
                        departments: "Array of departments mentioned"
                    }
                },
                authors: {
                    prompt: "Extract ONLY the document authors (not cited authors). Look specifically at the title page, header, or first page for names that appear with the document title or institutional affiliations. Ignore any names in references, citations, or bibliography sections.",
                    schema: {
                        title: "Document title from title page",
                        documentAuthors: "Array of document authors from title page/header - first and last names only, no titles",
                        authorInstitutions: "Array of institutional affiliations corresponding to each author",
                        correspondingAuthor: "Email or contact info for corresponding author if mentioned",
                        documentType: "Type of document (research paper, report, thesis, etc.)",
                        abstract: "Document abstract if present",
                        publicationInfo: "Journal name, conference, or publication venue if mentioned"
                    }
                },
                custom: {
                    prompt: "Extract the main information from this document",
                    schema: {
                        title: "Document title",
                        summary: "Brief summary",
                        keyInformation: "Array of key information points"
                    }
                }
            };
            
            const preset = presets[type];
            if (preset) {
                promptInput.value = preset.prompt;
                schemaInput.value = JSON.stringify(preset.schema, null, 2);
            }
        }
        
        // Extract structured data
        async function extractStructuredData() {
            if (!mind || !currentPdfId) {
                showMessage('Please load a PDF first', 'error');
                return;
            }
            
            const prompt = document.getElementById('extractPrompt').value.trim();
            const schemaText = document.getElementById('extractSchema').value.trim();
            
            if (!prompt || !schemaText) {
                showMessage('Please enter both a prompt and schema', 'error');
                return;
            }
            
            let schema;
            try {
                schema = JSON.parse(schemaText);
            } catch (error) {
                showMessage('Invalid JSON schema format', 'error');
                return;
            }
            
            const extractButton = document.getElementById('extractData');
            extractButton.disabled = true;
            extractButton.textContent = 'Extracting...';
            
            try {
                showMessage('Processing document and extracting structured data...', 'system');
                
                // Enhanced prompt for author extraction
                let enhancedPrompt = prompt;
                const isAuthorExtraction = JSON.stringify(schema).toLowerCase().includes('author');
                if (isAuthorExtraction) {
                    enhancedPrompt += "\n\nIMPORTANT: Focus on the document's own authors (from title page/header), NOT authors mentioned in citations or references. Look for names that appear:\n- Near the document title\n- In the header or footer\n- With institutional affiliations\n- Before the abstract\nIgnore names in bibliography, citations, or reference lists.";
                }
                
                // Use the streamlined PDF processing approach
                // This replaces the previous clunky method of manually getting PDF text via chat
                const result = await mind.process(enhancedPrompt, "pdf", schema);
                
                // Display results
                displayProcessResult(result);
                
                showMessage('Structured data extracted successfully!', 'success');
                
            } catch (error) {
                showMessage(`Failed to extract data: ${error.message}`, 'error');
                console.error('Extraction error:', error);
            } finally {
                extractButton.disabled = false;
                extractButton.textContent = 'Extract Structured Data';
            }
        }
        
        // Display process result
        function displayProcessResult(result) {
            const processResult = document.getElementById('processResult');
            const processOutput = document.getElementById('processOutput');
            
            let html = '';
            
            if (result.data) {
                html += '<div class="json-output">' + JSON.stringify(result.data, null, 2) + '</div>';
            } else {
                html += '<div class="json-output">' + JSON.stringify(result, null, 2) + '</div>';
            }
            
            if (result.usage) {
                html += `
                    <div style="margin-top: 10px; padding: 10px; background: #f0f8ff; border-radius: 4px; font-size: 12px;">
                        <strong>Token Usage:</strong> 
                        Prompt: ${result.usage.prompt_tokens || 0}, 
                        Completion: ${result.usage.completion_tokens || 0}, 
                        Total: ${result.usage.total_tokens || 0}
                    </div>
                `;
            } else {
                html += `
                    <div style="margin-top: 10px; padding: 10px; background: #fff3cd; border-radius: 4px; font-size: 12px; color: #856404;">
                        <strong>Note:</strong> Token usage information not available for this API endpoint.
                    </div>
                `;
            }
            
            processOutput.innerHTML = html;
            processResult.style.display = 'block';
        }
        
        // Clear process result
        function clearProcessResult() {
            const processResult = document.getElementById('processResult');
            processResult.style.display = 'none';
        }
        
        // Update extract button state
        function updateExtractButton() {
            const extractButton = document.getElementById('extractData');
            extractButton.disabled = !currentPdfId;
        }
        
        // Clear page range inputs
        function clearPageRange() {
            document.getElementById('pageRangeStart').value = '';
            document.getElementById('pageRangeEnd').value = '';
        }
        
        // Set page range preset
        function setPageRange(start, end) {
            document.getElementById('pageRangeStart').value = start;
            document.getElementById('pageRangeEnd').value = end;
            validatePageRange();
        }
        
        // Validate page range inputs
        function validatePageRange() {
            const startPage = parseInt(document.getElementById('pageRangeStart').value);
            const endPage = parseInt(document.getElementById('pageRangeEnd').value);
            
            if ((startPage && !endPage) || (!startPage && endPage)) {
                showMessage('Please specify both start and end page, or leave both empty', 'warning');
                return false;
            }
            
            if (startPage && endPage && startPage > endPage) {
                showMessage('Start page must be less than or equal to end page', 'warning');
                return false;
            }
            
            if (startPage && endPage && (endPage - startPage + 1) > 100) {
                showMessage('Page range cannot exceed 100 pages', 'warning');
                return false;
            }
            
            return true;
        }
        
        // Event listeners
        document.getElementById('loadPdf').addEventListener('click', () => {
            const fileInput = document.getElementById('pdfFile');
            const urlInput = document.getElementById('pdfUrl');
            
            if (fileInput.files[0]) {
                loadPdf(fileInput.files[0]);
            } else if (urlInput.value.trim()) {
                loadPdf(urlInput.value.trim());
            } else {
                showMessage('Please select a file or enter a URL', 'error');
            }
        });
        
        document.getElementById('loadExamplePdf').addEventListener('click', () => {
            loadPdf('examples/instrumental_interaction.pdf');
        });
        
        document.getElementById('clearRange').addEventListener('click', () => {
            clearPageRange();
            showMessage('Page range cleared - will process full document', 'system');
        });
        
        document.getElementById('sendMessage').addEventListener('click', sendMessage);
        
        document.getElementById('chatInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });
        
        document.getElementById('clearChat').addEventListener('click', clearChat);
        
        document.getElementById('refreshLibrary').addEventListener('click', updatePdfLibrary);
        
        document.getElementById('showStorage').addEventListener('click', showStorageInfo);
        
        document.getElementById('extractData').addEventListener('click', extractStructuredData);
        
        // Export/Import event listeners
        document.getElementById('exportPdfSelect').addEventListener('change', function() {
            document.getElementById('exportPdfBtn').disabled = !this.value;
        });
        document.getElementById('exportPdfBtn').addEventListener('click', exportPdf);
        document.getElementById('importPdfFile').addEventListener('change', function() {
            document.getElementById('importPdfBtn').disabled = !this.files[0];
        });
        document.getElementById('importPdfBtn').addEventListener('click', importPdf);
        
        // Page range validation on input
        document.getElementById('pageRangeStart').addEventListener('input', validatePageRange);
        document.getElementById('pageRangeEnd').addEventListener('input', validatePageRange);
        
        // Configuration button event listeners
        document.getElementById('initializeBtn').addEventListener('click', initWarpMind);
        document.getElementById('resetConfigBtn').addEventListener('click', resetConfiguration);
        
        // Initialize configuration form on page load
        window.addEventListener('load', initializeForm);
    </script>
</body>
</html>
