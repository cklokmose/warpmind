<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streaming Audio Test - WarpMind</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .test-section {
            border: 2px solid #e9ecef;
            margin: 20px 0;
            padding: 20px;
            border-radius: 8px;
            background: #f8f9fa;
        }
        h1 { 
            color: #2c3e50; 
            text-align: center; 
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        h2 { 
            color: #34495e; 
            margin-top: 0; 
            font-size: 1.5em;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        button {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            padding: 12px 20px;
            margin: 8px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        button:hover { 
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }
        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        button.streaming {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        textarea {
            width: 100%;
            height: 120px;
            margin: 10px 0;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            resize: vertical;
        }
        .output {
            background-color: #2c3e50;
            color: #ecf0f1;
            border: 2px solid #34495e;
            padding: 15px;
            margin: 15px 0;
            border-radius: 6px;
            white-space: pre-wrap;
            font-family: 'Consolas', monospace;
            min-height: 60px;
            font-size: 13px;
            line-height: 1.4;
        }
        .error {
            background-color: #e74c3c;
            border-color: #c0392b;
            color: white;
        }
        .success {
            background-color: #27ae60;
            border-color: #229954;
            color: white;
        }
        .streaming-info {
            background-color: #f39c12;
            border-color: #e67e22;
            color: white;
        }
        .input-group {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            align-items: center;
        }
        .input-group input {
            flex: 1;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }
        audio {
            width: 100%;
            margin: 15px 0;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        .metric {
            background: #34495e;
            color: white;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
        }
        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #3498db;
        }
        .note {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéµ WarpMind Streaming Audio Test</h1>
        
        <div class="note">
            <strong>Note:</strong> This example demonstrates the streaming capabilities of WarpMind's text-to-speech and speech-to-text features. 
            You'll need a valid API key to test the functionality.
        </div>
        
        <div class="test-section">
            <h2>üîß Configuration</h2>
            <div class="input-group">
                <input type="text" id="api-key" placeholder="Enter your API key" style="flex: 2;">
                <input type="text" id="base-url" placeholder="Base URL (optional)" value="https://warp.cs.au.dk/mind">
                <button onclick="initializeWarpmind()">Initialize</button>
            </div>
            <div id="config-output" class="output">Enter your API key and click Initialize to get started...</div>
        </div>

        <div class="test-section">
            <h2>üé§ Text to Speech Streaming</h2>
            <textarea id="tts-text" placeholder="Enter text to convert to speech...">Hello! This is a demonstration of the streaming text-to-speech functionality in WarpMind. You should see chunks arriving in real-time as the audio is generated.</textarea>
            
            <div style="margin: 15px 0;">
                <label>Voice: </label>
                <select id="tts-voice" style="padding: 5px; margin: 0 10px;">
                    <option value="alloy">Alloy</option>
                    <option value="echo">Echo</option>
                    <option value="fable">Fable</option>
                    <option value="onyx">Onyx</option>
                    <option value="nova">Nova</option>
                    <option value="shimmer">Shimmer</option>
                </select>
                
                <label>Format: </label>
                <select id="tts-format" style="padding: 5px; margin: 0 10px;">
                    <option value="mp3">MP3</option>
                    <option value="opus">Opus</option>
                    <option value="aac">AAC</option>
                    <option value="flac">FLAC</option>
                </select>
            </div>
            
            <button onclick="testTTSRegular()">Generate Speech (Regular)</button>
            <button onclick="testTTSStreaming()" id="tts-stream-btn">Generate Speech (Streaming)</button>
            
            <div class="metrics" id="tts-metrics" style="display: none;">
                <div class="metric">
                    <div class="metric-value" id="tts-chunks">0</div>
                    <div>Chunks Received</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="tts-size">0 KB</div>
                    <div>Total Size</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="tts-time">0s</div>
                    <div>Duration</div>
                </div>
            </div>
            
            <div id="tts-output" class="output">Audio output will appear here...</div>
            <audio id="tts-audio" controls style="display: none;"></audio>
        </div>

        <div class="test-section">
            <h2>üéôÔ∏è Speech to Text Streaming</h2>
            <div class="input-group">
                <input type="file" id="stt-file" accept="audio/*" style="flex: 1;">
                <select id="stt-language" style="padding: 10px;">
                    <option value="">Auto-detect</option>
                    <option value="en">English</option>
                    <option value="es">Spanish</option>
                    <option value="fr">French</option>
                    <option value="de">German</option>
                    <option value="zh">Chinese</option>
                </select>
            </div>
            
            <button onclick="testSTTRegular()">Transcribe (Regular)</button>
            <button onclick="testSTTStreaming()" id="stt-stream-btn">Transcribe (Streaming)</button>
            
            <div class="metrics" id="stt-metrics" style="display: none;">
                <div class="metric">
                    <div class="metric-value" id="stt-partials">0</div>
                    <div>Partial Results</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="stt-time">0s</div>
                    <div>Duration</div>
                </div>
            </div>
            
            <div id="stt-output" class="output">Transcription will appear here...</div>
        </div>
    </div>

    <!-- Load the WarpMind library -->
    <script src="../dist/warpmind.js"></script>

    <script>
        let warpMind = null;
        let ttsStartTime = 0;
        let sttStartTime = 0;

        function initializeWarpmind() {
            const apiKey = document.getElementById('api-key').value;
            const baseURL = document.getElementById('base-url').value;
            const output = document.getElementById('config-output');

            if (!apiKey) {
                output.textContent = 'Error: API key is required';
                output.className = 'output error';
                return;
            }

            try {
                warpMind = new WarpMind({
                    apiKey: apiKey,
                    baseURL: baseURL || 'https://warp.cs.au.dk/mind'
                });
                output.textContent = 'WarpMind initialized successfully! You can now test the streaming features.';
                output.className = 'output success';
                
                // Save API key for convenience
                localStorage.setItem('warpMind-api-key', apiKey);
            } catch (error) {
                output.textContent = `Error initializing WarpMind: ${error.message}`;
                output.className = 'output error';
            }
        }

        async function testTTSRegular() {
            if (!warpMind) {
                alert('Please initialize WarpMind first');
                return;
            }

            const text = document.getElementById('tts-text').value;
            const voice = document.getElementById('tts-voice').value;
            const format = document.getElementById('tts-format').value;
            const output = document.getElementById('tts-output');
            const audio = document.getElementById('tts-audio');

            if (!text.trim()) {
                output.textContent = 'Error: Please enter some text to convert';
                output.className = 'output error';
                return;
            }

            output.textContent = 'Generating speech (regular mode)...';
            output.className = 'output';
            
            const startTime = Date.now();

            try {
                const audioBlob = await warpMind.textToSpeech(text, {
                    voice: voice,
                    format: format
                });

                const duration = (Date.now() - startTime) / 1000;
                const audioUrl = URL.createObjectURL(audioBlob);
                audio.src = audioUrl;
                audio.style.display = 'block';
                
                output.textContent = `Speech generated successfully!\nSize: ${(audioBlob.size / 1024).toFixed(1)} KB\nTime: ${duration.toFixed(1)}s\nVoice: ${voice}\nFormat: ${format}`;
                output.className = 'output success';
            } catch (error) {
                output.textContent = `Error: ${error.message}`;
                output.className = 'output error';
            }
        }

        async function testTTSStreaming() {
            if (!warpMind) {
                alert('Please initialize WarpMind first');
                return;
            }

            const text = document.getElementById('tts-text').value;
            const voice = document.getElementById('tts-voice').value;
            const format = document.getElementById('tts-format').value;
            const output = document.getElementById('tts-output');
            const audio = document.getElementById('tts-audio');
            const metrics = document.getElementById('tts-metrics');
            const button = document.getElementById('tts-stream-btn');

            if (!text.trim()) {
                output.textContent = 'Error: Please enter some text to convert';
                output.className = 'output error';
                return;
            }

            // Show metrics and update UI
            metrics.style.display = 'grid';
            button.textContent = 'Streaming...';
            button.className = 'streaming';
            button.disabled = true;

            output.textContent = 'Generating speech with streaming...';
            output.className = 'output streaming-info';

            let chunkCount = 0;
            let totalSize = 0;
            ttsStartTime = Date.now();

            try {
                const audioBlob = await warpMind.textToSpeech(text, {
                    voice: voice,
                    format: format,
                    stream: true,
                    onChunk: (chunk) => {
                        chunkCount++;
                        totalSize += chunk.byteLength;
                        
                        const elapsed = (Date.now() - ttsStartTime) / 1000;
                        
                        // Update metrics
                        document.getElementById('tts-chunks').textContent = chunkCount;
                        document.getElementById('tts-size').textContent = `${(totalSize / 1024).toFixed(1)} KB`;
                        document.getElementById('tts-time').textContent = `${elapsed.toFixed(1)}s`;
                        
                        output.textContent = `Streaming audio...\nChunks: ${chunkCount}\nSize: ${(totalSize / 1024).toFixed(1)} KB\nElapsed: ${elapsed.toFixed(1)}s`;
                    }
                });

                const duration = (Date.now() - ttsStartTime) / 1000;
                const audioUrl = URL.createObjectURL(audioBlob);
                audio.src = audioUrl;
                audio.style.display = 'block';
                
                // Final metrics
                document.getElementById('tts-time').textContent = `${duration.toFixed(1)}s`;
                
                output.textContent = `Streaming completed!\nTotal chunks: ${chunkCount}\nFinal size: ${(audioBlob.size / 1024).toFixed(1)} KB\nDuration: ${duration.toFixed(1)}s\nVoice: ${voice}\nFormat: ${format}`;
                output.className = 'output success';
            } catch (error) {
                output.textContent = `Error: ${error.message}`;
                output.className = 'output error';
            } finally {
                button.textContent = 'Generate Speech (Streaming)';
                button.className = '';
                button.disabled = false;
            }
        }

        async function testSTTRegular() {
            if (!warpMind) {
                alert('Please initialize WarpMind first');
                return;
            }

            const fileInput = document.getElementById('stt-file');
            const language = document.getElementById('stt-language').value;
            const output = document.getElementById('stt-output');

            if (!fileInput.files[0]) {
                output.textContent = 'Error: Please select an audio file';
                output.className = 'output error';
                return;
            }

            output.textContent = 'Transcribing audio (regular mode)...';
            output.className = 'output';
            
            const startTime = Date.now();

            try {
                const options = { model: 'whisper-1' };
                if (language) options.language = language;
                
                const text = await warpMind.speechToText(fileInput.files[0], options);
                const duration = (Date.now() - startTime) / 1000;

                output.textContent = `Transcription completed!\nDuration: ${duration.toFixed(1)}s\nLanguage: ${language || 'auto-detect'}\n\nResult:\n${text}`;
                output.className = 'output success';
            } catch (error) {
                output.textContent = `Error: ${error.message}`;
                output.className = 'output error';
            }
        }

        async function testSTTStreaming() {
            if (!warpMind) {
                alert('Please initialize WarpMind first');
                return;
            }

            const fileInput = document.getElementById('stt-file');
            const language = document.getElementById('stt-language').value;
            const output = document.getElementById('stt-output');
            const metrics = document.getElementById('stt-metrics');
            const button = document.getElementById('stt-stream-btn');

            if (!fileInput.files[0]) {
                output.textContent = 'Error: Please select an audio file';
                output.className = 'output error';
                return;
            }

            // Show metrics and update UI
            metrics.style.display = 'grid';
            button.textContent = 'Streaming...';
            button.className = 'streaming';
            button.disabled = true;

            output.textContent = 'Transcribing audio with streaming...';
            output.className = 'output streaming-info';

            let partialCount = 0;
            sttStartTime = Date.now();

            try {
                const options = { 
                    model: 'whisper-1',
                    stream: true,
                    onPartial: (partialText) => {
                        partialCount++;
                        const elapsed = (Date.now() - sttStartTime) / 1000;
                        
                        // Update metrics
                        document.getElementById('stt-partials').textContent = partialCount;
                        document.getElementById('stt-time').textContent = `${elapsed.toFixed(1)}s`;
                        
                        output.textContent = `Streaming transcription...\nPartial results: ${partialCount}\nElapsed: ${elapsed.toFixed(1)}s\n\nCurrent:\n${partialText}`;
                    }
                };
                
                if (language) options.language = language;
                
                const finalText = await warpMind.speechToText(fileInput.files[0], options);
                const duration = (Date.now() - sttStartTime) / 1000;
                
                // Final metrics
                document.getElementById('stt-time').textContent = `${duration.toFixed(1)}s`;

                output.textContent = `Streaming completed!\nPartial results: ${partialCount}\nDuration: ${duration.toFixed(1)}s\nLanguage: ${language || 'auto-detect'}\n\nFinal result:\n${finalText}`;
                output.className = 'output success';
            } catch (error) {
                output.textContent = `Error: ${error.message}`;
                output.className = 'output error';
            } finally {
                button.textContent = 'Transcribe (Streaming)';
                button.className = '';
                button.disabled = false;
            }
        }

        // Initialize on page load
        window.onload = function() {
            // Try to load saved API key
            const savedApiKey = localStorage.getItem('warpMind-api-key');
            if (savedApiKey) {
                document.getElementById('api-key').value = savedApiKey;
            }
        };
    </script>
</body>
</html>
