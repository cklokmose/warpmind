<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete WarpMind Test Suite</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 1000px; margin: 0 auto; padding: 20px; }
        .test-section { border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 5px; }
        .test-section h2 { margin-top: 0; color: #333; }
        button { padding: 10px 15px; margin: 5px; font-size: 14px; cursor: pointer; }
        .success { background-color: #d4edda; border-color: #c3e6cb; color: #155724; }
        .error { background-color: #f8d7da; border-color: #f5c6cb; color: #721c24; }
        .info { background-color: #d1ecf1; border-color: #bee5eb; color: #0c5460; }
        #output { background: #f8f9fa; padding: 15px; margin: 10px 0; border-radius: 5px; 
                 max-height: 400px; overflow-y: auto; font-family: monospace; white-space: pre-wrap; }
        .recording { background-color: #dc3545 !important; color: white; }
        input[type="file"] { margin: 10px 0; }
        textarea { width: 100%; height: 60px; margin: 5px 0; }
        .test-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        @media (max-width: 768px) { .test-grid { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <h1>üöÄ Complete WarpMind Test Suite</h1>
    <p>Testing all functionality with Warp CS AI API (https://warp.cs.au.dk/mind)</p>        <!-- Configuration Section -->
        <div class="test-section" style="background-color: #f8f9fa; border: 2px solid #007cba;">
            <h2>‚öôÔ∏è Configuration</h2>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                <div>
                    <label for="serverURL" style="display: block; margin-bottom: 5px; font-weight: bold;">Server URL:</label>
                    <input type="text" id="serverURL" placeholder="https://warp.cs.au.dk/mind" 
                           style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                </div>
                <div>
                    <label for="apiKeyInput" style="display: block; margin-bottom: 5px; font-weight: bold;">API Key (optional):</label>
                    <input type="password" id="apiKeyInput" placeholder="Leave empty for automatic prompting" 
                           style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                </div>
            </div>
            <div style="text-align: center;">
                <button onclick="updateConfiguration()" style="background-color: #007cba; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin-right: 10px;">
                    üîÑ Update Configuration
                </button>
                <button onclick="resetConfiguration()" style="background-color: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer;">
                    üîÑ Reset to Defaults
                </button>
            </div>
            <div id="configStatus" style="margin-top: 10px; padding: 10px; border-radius: 4px; text-align: center; display: none;"></div>
        </div>
    
    <div id="output">Initializing tests...</div>

    <div class="test-grid">
        <!-- Basic Tests -->
        <div class="test-section">
            <h2>üìù Basic Text Functions</h2>
            <button onclick="testChat()">Test Chat</button>
            <button onclick="testCompletion()">Test Completion</button>
            <button onclick="testStreaming()">Test Streaming</button>
            <textarea id="chatInput" placeholder="Enter your message here...">Hello, how are you?</textarea>
        </div>

        <!-- Image Analysis -->
        <div class="test-section">
            <h2>üñºÔ∏è Image Analysis</h2>
            <input type="file" id="imageFile" accept="image/*">
            <button onclick="testImageAnalysis()">Analyze Image</button>
            <button onclick="testImageURL()">Test with URL</button>
            <textarea id="imagePrompt" placeholder="What to ask about the image...">What do you see in this image?</textarea>
        </div>

        <!-- Text to Speech -->
        <div class="test-section">
            <h2>üîä Text-to-Speech</h2>
            <button onclick="testTTS()">Generate Speech</button>
            <button onclick="testTTSVoices()">Test Different Voices</button>
            <textarea id="ttsText" placeholder="Text to convert to speech...">Hello, this is a test of text to speech functionality.</textarea>
        </div>

        <!-- Speech to Text -->
        <div class="test-section">
            <h2>üé§ Speech-to-Text</h2>
            <button id="recordBtn" onclick="startRecording()">üé§ Start Recording</button>
            <button id="stopBtn" onclick="stopRecording()" disabled>‚èπÔ∏è Stop Recording</button>
            <input type="file" id="audioFile" accept="audio/*">
            <button onclick="testSTTFile()">Test Audio File</button>
        </div>

        <!-- Voice Chat -->
        <div class="test-section">
            <h2>üí¨ Voice Chat</h2>
            <button id="voiceStartBtn" onclick="startVoiceChat()">üé§ Start Voice Chat</button>
            <button id="voiceStopBtn" onclick="stopVoiceChat()" disabled>‚èπÔ∏è Stop Voice Chat</button>
            <button onclick="clearVoiceChat()">üóëÔ∏è Clear History</button>
            <textarea id="systemPrompt" placeholder="System prompt...">You are a helpful assistant. Keep responses brief.</textarea>
        </div>

        <!-- Structured Data Processing -->
        <div class="test-section">
            <h2>üîß Structured Data Processing</h2>
            <button onclick="testSimpleProcess()">Simple Processing</button>
            <button onclick="testSentimentAnalysis()">Sentiment Analysis</button>
            <button onclick="testDataExtraction()">Data Extraction</button>
            <button onclick="testComplexProcessing()">Complex Processing</button>
            <button onclick="testProcessingEdgeCases()">Edge Cases</button>
            <div id="currentTest" style="background: #e9ecef; padding: 10px; margin: 10px 0; border-radius: 4px; font-family: monospace; font-size: 12px; max-height: 150px; overflow-y: auto; display: none;">
                <strong>Current Test Data:</strong>
                <div id="testData"></div>
            </div>
        </div>

        <!-- Tool Calling System -->
        <div class="test-section">
            <h2>üõ†Ô∏è Tool Calling System</h2>
            <button onclick="registerTestTools()">Register Test Tools</button>
            <button onclick="testWeatherTool()">Test Weather Tool</button>
            <button onclick="testCalculatorTool()">Test Calculator Tool</button>
            <button onclick="testMultipleTools()">Test Multiple Tools</button>
            <button onclick="testToolErrors()">Test Error Handling</button>
            <button onclick="clearTools()">Clear All Tools</button>
            <div style="margin: 10px 0; border-top: 1px solid #ddd; padding-top: 10px;">
                <strong>üîß Tool Call Inspection:</strong><br>
                <button onclick="testToolCallbacks()">Test Tool Callbacks</button>
                <button onclick="testMetadataReturn()">Test Metadata Return</button>
                <button onclick="testStreamingWithCallbacks()">Test Streaming + Callbacks</button>
                <button onclick="clearToolMonitor()">Clear Monitor</button>
            </div>
            <div id="registeredTools" style="background: #e7f3ff; padding: 10px; margin: 10px 0; border-radius: 4px; font-family: monospace; font-size: 12px; display: none;">
                <strong>Registered Tools:</strong>
                <div id="toolsList"></div>
            </div>
            <div id="toolCallMonitor" style="background: #f5f5f5; padding: 10px; margin: 10px 0; border-radius: 4px; font-family: monospace; font-size: 12px; max-height: 200px; overflow-y: auto; display: none;">
                <strong>Tool Call Monitor:</strong>
                <div id="toolCallLog"></div>
            </div>
            <textarea id="toolPrompt" placeholder="Ask something that requires tools...">What's the weather in Paris and what's 15% tip on a $47.50 bill?</textarea>
        </div>

        <!-- Stress Tests -->
        <div class="test-section">
            <h2>‚ö° Performance Tests</h2>
            <button onclick="runStressTest()">Run Stress Test</button>
            <button onclick="testConcurrency()">Test Concurrent Requests</button>
            <button onclick="testLargeFile()">Test Large Audio File</button>
        </div>
    </div>

    <script src="../dist/warpmind.js"></script>
    <script>
        // Configuration management
        const DEFAULT_CONFIG = {
            baseURL: 'https://warp.cs.au.dk/mind',
            // apiKey removed - will use automatic prompting
        };

        // Load configuration from localStorage or use defaults
        function loadConfiguration() {
            const savedConfig = localStorage.getItem('warpMind-test-config');
            if (savedConfig) {
                try {
                    return JSON.parse(savedConfig);
                } catch (e) {
                    console.warn('Failed to parse saved config, using defaults');
                    return DEFAULT_CONFIG;
                }
            }
            return DEFAULT_CONFIG;
        }

        // Save configuration to localStorage
        function saveConfiguration(config) {
            localStorage.setItem('warpMind-test-config', JSON.stringify(config));
        }

        // Initialize configuration
        let currentConfig = loadConfiguration();
        
        // Initialize WarpMind with current configuration
        let wm = new WarpMind(currentConfig);

        // Update configuration from form inputs
        function updateConfiguration() {
            const serverURL = document.getElementById('serverURL').value.trim();
            const apiKey = document.getElementById('apiKeyInput').value.trim();
            
            if (!serverURL) {
                showConfigStatus('Please enter a server URL', 'error');
                return;
            }

            // Build configuration object
            const newConfig = { baseURL: serverURL };
            if (apiKey) {
                newConfig.apiKey = apiKey;
            }
            // If no API key is provided, WarpMind will automatically prompt for one

            currentConfig = newConfig;
            saveConfiguration(currentConfig);
            
            // Reinitialize WarpMind with new config
            wm = new WarpMind(currentConfig);
            
            showConfigStatus('Configuration updated successfully!', 'success');
            log('üîÑ Configuration updated and saved to localStorage');
            log(`üåê Using server: ${serverURL}`);
            if (apiKey) {
                log(`üîë Using provided API key`);
            } else {
                log(`üîë No API key provided - will prompt automatically when needed`);
            }
            
            // Test the new configuration
            testConnection();
        }

        // Reset configuration to defaults
        function resetConfiguration() {
            currentConfig = { ...DEFAULT_CONFIG };
            saveConfiguration(currentConfig);
            
            // Update form inputs
            document.getElementById('serverURL').value = currentConfig.baseURL;
            document.getElementById('apiKeyInput').value = currentConfig.apiKey || '';
            
            // Reinitialize WarpMind
            wm = new WarpMind(currentConfig);
            
            showConfigStatus('Configuration reset to defaults', 'info');
            log('üîÑ Configuration reset to defaults');
            
            // Test the configuration
            testConnection();
        }

        // Show configuration status message
        function showConfigStatus(message, type) {
            const statusDiv = document.getElementById('configStatus');
            statusDiv.style.display = 'block';
            statusDiv.textContent = message;
            statusDiv.className = type;
            
            // Hide after 3 seconds
            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 3000);
        }

        // Initialize form inputs with current configuration
        function initializeForm() {
            document.getElementById('serverURL').value = currentConfig.baseURL;
            document.getElementById('apiKeyInput').value = currentConfig.apiKey || '';
        }

        const output = document.getElementById('output');
        let voiceChat = null;
        let isRecording = false;
        let mediaRecorder = null;
        let audioChunks = [];

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : '‚ÑπÔ∏è';
            output.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            output.scrollTop = output.scrollHeight;
        }

        function clearLog() {
            output.textContent = '';
        }

        // Show what data is being processed in each test
        function showTestData(testName, prompt, data, schema) {
            const testDiv = document.getElementById('currentTest');
            const dataDiv = document.getElementById('testData');
            
            let dataDisplay = '';
            if (data === null) {
                dataDisplay = 'null (no input data)';
            } else if (typeof data === 'string') {
                dataDisplay = `"${data}"`;
            } else {
                dataDisplay = JSON.stringify(data, null, 2);
            }
            
            dataDiv.innerHTML = `
                <div><strong>Test:</strong> ${testName}</div>
                <div><strong>Prompt:</strong> "${prompt}"</div>
                <div><strong>Input Data:</strong> ${dataDisplay}</div>
                <div><strong>Expected Schema:</strong> ${JSON.stringify(schema, null, 2)}</div>
            `;
            
            testDiv.style.display = 'block';
        }

        // Basic Text Tests
        async function testChat() {
            try {
                log('Testing basic chat...');
                const message = document.getElementById('chatInput').value;
                const response = await wm.chat(message);
                log(`Chat response: "${response}"`, 'success');
            } catch (error) {
                log(`Chat failed: ${error.message}`, 'error');
            }
        }

        async function testCompletion() {
            try {
                log('Testing completion...');
                const message = document.getElementById('chatInput').value;
                const response = await wm.complete(message);
                log(`Completion response: "${response}"`, 'success');
            } catch (error) {
                log(`Completion failed: ${error.message}`, 'error');
            }
        }

        async function testStreaming() {
            try {
                log('Testing streaming chat...');
                const message = document.getElementById('chatInput').value;
                let streamedText = '';
                let chunkCount = 0;
                
                // Create a temporary element to show streaming text as it arrives
                const streamingElement = document.createElement('div');
                streamingElement.style.cssText = 'background: #e3f2fd; padding: 10px; margin: 5px 0; border-radius: 4px; border-left: 4px solid #2196f3;';
                streamingElement.innerHTML = '<strong>üåä Streaming Response:</strong><br><span id="streamContent" style="white-space: pre-wrap;"></span>';
                output.appendChild(streamingElement);
                
                const streamContent = document.getElementById('streamContent');
                
                await wm.streamChat(message, (chunk) => {
                    chunkCount++;
                    
                    // Handle both old format (string) and new format (object with content)
                    let content = '';
                    if (typeof chunk === 'string') {
                        content = chunk;
                    } else if (chunk && chunk.content) {
                        content = chunk.content;
                    }
                    
                    // Add the chunk content to our accumulated text
                    if (content !== null && content !== undefined) {
                        streamedText += content;
                        // Update the DOM immediately with the new content
                        streamContent.textContent = streamedText;
                        
                        // Auto-scroll to bottom to follow the streaming text
                        output.scrollTop = output.scrollHeight;
                    }
                });
                
                log(`‚úÖ Streaming completed! Received ${chunkCount} chunks with ${streamedText.length} total characters.`, 'success');
            } catch (error) {
                log(`Streaming failed: ${error.message}`, 'error');
            }
        }

        // Image Analysis Tests
        async function testImageAnalysis() {
            const file = document.getElementById('imageFile').files[0];
            if (!file) {
                log('Please select an image file first', 'error');
                return;
            }

            try {
                log(`Analyzing image: ${file.name}...`);
                const prompt = document.getElementById('imagePrompt').value;
                const response = await wm.analyzeImage(file, prompt);
                log(`Image analysis: "${response}"`, 'success');
            } catch (error) {
                log(`Image analysis failed: ${error.message}`, 'error');
            }
        }

        async function testImageURL() {
            try {
                log('Testing image analysis with URL...');
                const prompt = document.getElementById('imagePrompt').value;
                const response = await wm.analyzeImage(
                    'https://upload.wikimedia.org/wikipedia/commons/thumb/d/dd/Gfp-wisconsin-madison-the-nature-boardwalk.jpg/2560px-Gfp-wisconsin-madison-the-nature-boardwalk.jpg',
                    prompt
                );
                log(`URL image analysis: "${response}"`, 'success');
            } catch (error) {
                log(`URL image analysis failed: ${error.message}`, 'error');
            }
        }

        // TTS Tests
        async function testTTS() {
            try {
                log('Testing text-to-speech...');
                const text = document.getElementById('ttsText').value;
                const audioBlob = await wm.textToSpeech(text);
                log(`TTS successful: ${audioBlob.size} bytes`, 'success');
                
                // Play the audio
                await wm.playAudio(audioBlob);
                log('TTS audio played successfully', 'success');
            } catch (error) {
                log(`TTS failed: ${error.message}`, 'error');
            }
        }

        async function testTTSVoices() {
            const voices = ['alloy', 'echo', 'fable', 'onyx', 'nova', 'shimmer'];
            const text = 'Testing different voices';
            
            for (const voice of voices) {
                try {
                    log(`Testing TTS with voice: ${voice}...`);
                    const audioBlob = await wm.textToSpeech(text, { voice });
                    log(`Voice ${voice}: ${audioBlob.size} bytes`, 'success');
                } catch (error) {
                    log(`Voice ${voice} failed: ${error.message}`, 'error');
                }
            }
        }

        // STT Tests
        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                mediaRecorder.start();
                isRecording = true;
                
                document.getElementById('recordBtn').disabled = true;
                document.getElementById('recordBtn').classList.add('recording');
                document.getElementById('stopBtn').disabled = false;
                
                log('üé§ Recording started... Speak now!');
            } catch (error) {
                log(`Recording failed: ${error.message}`, 'error');
            }
        }

        async function stopRecording() {
            if (!isRecording || !mediaRecorder) return;

            mediaRecorder.onstop = async () => {
                try {
                    log('‚è≥ Processing recorded audio...');
                    const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                    
                    const transcription = await wm.speechToText(audioBlob);
                    log(`STT result: "${transcription}"`, 'success');
                    
                } catch (error) {
                    log(`STT failed: ${error.message}`, 'error');
                } finally {
                    // Clean up
                    mediaRecorder.stream.getTracks().forEach(track => track.stop());
                    isRecording = false;
                    document.getElementById('recordBtn').disabled = false;
                    document.getElementById('recordBtn').classList.remove('recording');
                    document.getElementById('stopBtn').disabled = true;
                }
            };

            mediaRecorder.stop();
        }

        async function testSTTFile() {
            const file = document.getElementById('audioFile').files[0];
            if (!file) {
                log('Please select an audio file first', 'error');
                return;
            }

            try {
                log(`Transcribing file: ${file.name}...`);
                const transcription = await wm.speechToText(file);
                log(`File STT result: "${transcription}"`, 'success');
            } catch (error) {
                log(`File STT failed: ${error.message}`, 'error');
            }
        }

        // Voice Chat Tests
        async function startVoiceChat() {
            try {
                const systemPrompt = document.getElementById('systemPrompt').value;
                voiceChat = wm.createVoiceChat(systemPrompt);
                
                await voiceChat.startRecording();
                
                document.getElementById('voiceStartBtn').disabled = true;
                document.getElementById('voiceStartBtn').classList.add('recording');
                document.getElementById('voiceStopBtn').disabled = false;
                
                log('üé§ Voice chat started... Speak your message!');
            } catch (error) {
                log(`Voice chat start failed: ${error.message}`, 'error');
            }
        }

        async function stopVoiceChat() {
            if (!voiceChat) return;

            try {
                log('‚è≥ Processing voice chat...');
                const result = await voiceChat.stopRecordingAndRespond();
                
                log(`You said: "${result.userMessage}"`, 'success');
                log(`AI replied: "${result.aiResponse}"`, 'success');
                
                // Play AI response - fix: use result.audioBlob instead of result.speechBlob
                if (result.audioBlob) {
                    await wm.playAudio(result.audioBlob);
                    log('AI response played', 'success');
                } else {
                    log('No audio blob returned for AI response', 'error');
                }
                
            } catch (error) {
                log(`Voice chat failed: ${error.message}`, 'error');
            } finally {
                document.getElementById('voiceStartBtn').disabled = false;
                document.getElementById('voiceStartBtn').classList.remove('recording');
                document.getElementById('voiceStopBtn').disabled = true;
            }
        }

        function clearVoiceChat() {
            if (voiceChat) {
                voiceChat.clearConversation();
                log('Voice chat history cleared', 'success');
            }
        }

        // Tool Calling Tests
        function registerTestTools() {
            log('üõ†Ô∏è Registering test tools...');
            
            // Weather tool
            wm.registerTool({
                name: 'getWeather',
                description: 'Get current weather information for a city',
                parameters: {
                    type: 'object',
                    properties: {
                        city: { type: 'string', description: 'The city name' },
                        units: { type: 'string', enum: ['celsius', 'fahrenheit'], description: 'Temperature units' }
                    },
                    required: ['city']
                },
                handler: async (args) => {
                    // Simulate weather API call
                    const temps = { celsius: Math.floor(Math.random() * 35), fahrenheit: Math.floor(Math.random() * 95) };
                    const conditions = ['sunny', 'cloudy', 'rainy', 'snowy', 'windy'];
                    const condition = conditions[Math.floor(Math.random() * conditions.length)];
                    
                    const unit = args.units || 'celsius';
                    return {
                        city: args.city,
                        temperature: temps[unit],
                        unit: unit,
                        condition: condition,
                        humidity: Math.floor(Math.random() * 100),
                        timestamp: new Date().toISOString()
                    };
                }
            });

            // Calculator tool
            wm.registerTool({
                name: 'calculator',
                description: 'Perform basic mathematical calculations',
                parameters: {
                    type: 'object',
                    properties: {
                        operation: { type: 'string', enum: ['add', 'subtract', 'multiply', 'divide', 'percentage'] },
                        a: { type: 'number', description: 'First number' },
                        b: { type: 'number', description: 'Second number' },
                        percentage: { type: 'number', description: 'Percentage value (for percentage calculations)' }
                    },
                    required: ['operation']
                },
                handler: async (args) => {
                    const { operation, a, b, percentage } = args;
                    let result;
                    
                    switch (operation) {
                        case 'add':
                            result = a + b;
                            break;
                        case 'subtract':
                            result = a - b;
                            break;
                        case 'multiply':
                            result = a * b;
                            break;
                        case 'divide':
                            if (b === 0) throw new Error('Division by zero');
                            result = a / b;
                            break;
                        case 'percentage':
                            result = (percentage / 100) * a;
                            break;
                        default:
                            throw new Error(`Unknown operation: ${operation}`);
                    }
                    
                    return {
                        operation,
                        input: args,
                        result: Math.round(result * 100) / 100, // Round to 2 decimal places
                        timestamp: new Date().toISOString()
                    };
                }
            });

            // Library search tool
            wm.registerTool({
                name: 'searchLibrary',
                description: 'Search a school library catalog for books',
                parameters: {
                    type: 'object',
                    properties: {
                        title: { type: 'string', description: 'Book title to search for' },
                        author: { type: 'string', description: 'Author name to search for' },
                        genre: { type: 'string', description: 'Book genre/category' }
                    },
                    required: ['title']
                },
                handler: async (args) => {
                    // Simulate library search
                    const mockBooks = [
                        { title: 'The Great Gatsby', author: 'F. Scott Fitzgerald', genre: 'Fiction', available: true },
                        { title: 'To Kill a Mockingbird', author: 'Harper Lee', genre: 'Fiction', available: false },
                        { title: '1984', author: 'George Orwell', genre: 'Dystopian Fiction', available: true },
                        { title: 'Pride and Prejudice', author: 'Jane Austen', genre: 'Romance', available: true },
                        { title: 'The Catcher in the Rye', author: 'J.D. Salinger', genre: 'Fiction', available: false }
                    ];
                    
                    // Simple search simulation
                    const searchTerm = args.title.toLowerCase();
                    const matches = mockBooks.filter(book => 
                        book.title.toLowerCase().includes(searchTerm) ||
                        book.author.toLowerCase().includes(searchTerm) ||
                        (args.genre && book.genre.toLowerCase().includes(args.genre.toLowerCase()))
                    );
                    
                    return {
                        searchQuery: args,
                        totalResults: matches.length,
                        books: matches,
                        timestamp: new Date().toISOString()
                    };
                }
            });

            updateToolsList();
            log('‚úÖ Test tools registered successfully!', 'success');
            log('Registered: getWeather, calculator, searchLibrary', 'success');
        }

        async function testWeatherTool() {
            try {
                log('Testing weather tool via chat...');
                const response = await wm.chat("What's the weather like in Tokyo?");
                log(`Weather tool response: "${response}"`, 'success');
            } catch (error) {
                log(`Weather tool test failed: ${error.message}`, 'error');
            }
        }

        async function testCalculatorTool() {
            try {
                log('Testing calculator tool via chat...');
                const response = await wm.chat("What's 15% tip on a $47.50 restaurant bill?");
                log(`Calculator tool response: "${response}"`, 'success');
            } catch (error) {
                log(`Calculator tool test failed: ${error.message}`, 'error');
            }
        }

        async function testMultipleTools() {
            try {
                log('Testing multiple tools in one conversation...');
                const prompt = document.getElementById('toolPrompt').value || 
                    "What's the weather in London and calculate 20% of 150, and find books about JavaScript";
                
                const response = await wm.chat(prompt);
                log(`Multiple tools response: "${response}"`, 'success');
            } catch (error) {
                log(`Multiple tools test failed: ${error.message}`, 'error');
            }
        }

        async function testToolErrors() {
            try {
                log('Testing tool error handling...');
                
                // Register a tool that will fail
                wm.registerTool({
                    name: 'failingTool',
                    description: 'A tool that always fails for testing error handling',
                    parameters: {
                        type: 'object',
                        properties: {
                            input: { type: 'string' }
                        },
                        required: ['input']
                    },
                    handler: async (args) => {
                        throw new Error('This tool intentionally fails for testing');
                    }
                });

                updateToolsList();
                
                const response = await wm.chat("Use the failing tool with some input");
                log(`Error handling response: "${response}"`, 'success');
            } catch (error) {
                log(`Tool error test failed: ${error.message}`, 'error');
            }
        }

        function clearTools() {
            // Reset warpMind instance to clear tools
            wm = new WarpMind(currentConfig);
            updateToolsList();
            log('üóëÔ∏è All tools cleared', 'success');
        }

        function updateToolsList() {
            const toolsDiv = document.getElementById('registeredTools');
            const listDiv = document.getElementById('toolsList');
            
            if (wm._tools && wm._tools.length > 0) {
                toolsDiv.style.display = 'block';
                listDiv.innerHTML = wm._tools.map(tool => `‚Ä¢ ${tool.schema.function.name}`).join('<br>');
            } else {
                toolsDiv.style.display = 'none';
            }
        }

        // Performance and Stress Tests
        async function runStressTest() {
            try {
                log('üî• Running stress test with exponential backoff...');
                
                // Mock the original fetch to simulate retry behavior
                const originalFetch = window.fetch;
                let attemptCount = 0;
                
                window.fetch = async (url, options) => {
                    attemptCount++;
                    log(`Retry attempt ${attemptCount} to ${url}`);
                    
                    if (attemptCount < 3) {
                        // Simulate rate limiting for first 2 attempts
                        return {
                            ok: false,
                            status: 429,
                            statusText: 'Too Many Requests',
                            headers: new Headers({ 'retry-after': '1' }),
                            json: async () => ({ error: 'Rate limited' })
                        };
                    }
                    
                    // Restore original fetch and allow success
                    window.fetch = originalFetch;
                    return originalFetch(url, options);
                };
                
                const response = await wm.chat('Test message for retry logic');
                log(`‚úÖ Stress test completed after ${attemptCount} attempts: "${response}"`, 'success');
                
                // Restore original fetch
                window.fetch = originalFetch;
            } catch (error) {
                log(`‚ùå Stress test failed: ${error.message}`, 'error');
                // Restore original fetch in case of error
                if (window.fetch !== fetch) {
                    window.fetch = fetch;
                }
            }
        }

        async function testConcurrency() {
            try {
                log('üîÑ Testing concurrent requests...');
                const startTime = Date.now();
                
                // Run 5 concurrent chat requests
                const promises = [];
                for (let i = 1; i <= 5; i++) {
                    promises.push(wm.chat(`Concurrent request ${i}: What is 2+2?`));
                }
                
                const results = await Promise.all(promises);
                const endTime = Date.now();
                
                log(`‚úÖ Concurrency test completed in ${endTime - startTime}ms`, 'success');
                results.forEach((result, i) => {
                    log(`Response ${i + 1}: "${result}"`, 'success');
                });
            } catch (error) {
                log(`‚ùå Concurrency test failed: ${error.message}`, 'error');
            }
        }

        async function testLargeFile() {
            try {
                log('üìÅ Testing large file handling...');
                
                // Create a large text for TTS
                const largeText = 'This is a test of large file processing. '.repeat(100);
                log(`Generating TTS for ${largeText.length} characters...`);
                
                const audioBlob = await wm.textToSpeech(largeText);
                log(`‚úÖ Large TTS completed: ${audioBlob.size} bytes`, 'success');
                
                // Test with the generated audio for STT
                log('Testing STT with large audio file...');
                const transcript = await wm.speechToText(audioBlob);
                log(`‚úÖ Large STT completed: "${transcript.substring(0, 100)}..."`, 'success');
            } catch (error) {
                log(`‚ùå Large file test failed: ${error.message}`, 'error');
            }
        }

        // Process Method Tests
        async function testSimpleProcess() {
            try {
                log('Testing simple process method...');
                const data = "I just received my order and I'm really impressed! The quality is excellent and it arrived faster than expected. Definitely recommend this to others.";
                const prompt = "Analyze this text";
                const schema = {
                    sentiment: "positive, negative, or neutral",
                    confidence: "confidence score from 0 to 1",
                    wordCount: "number of words"
                };
                
                showTestData('Simple Processing', prompt, data, schema);
                
                const result = await wm.process(prompt, data, schema);
                log(`Simple process result: ${JSON.stringify(result, null, 2)}`, 'success');
            } catch (error) {
                log(`Simple process failed: ${error.message}`, 'error');
            }
        }

        async function testSentimentAnalysis() {
            try {
                log('Testing sentiment analysis...');
                const testTexts = [
                    "I absolutely love this product! Best purchase ever!",
                    "This is terrible. Worst experience of my life.",
                    "It's okay, nothing special but not bad either."
                ];
                const prompt = "Analyze the sentiment and emotions";
                const schema = {
                    sentiment: "positive, negative, or neutral",
                    emotions: "array of detected emotions",
                    intensity: "emotional intensity from 1-10",
                    keywords: "array of important sentiment words"
                };
                
                showTestData('Sentiment Analysis', prompt, testTexts, schema);
                
                for (let i = 0; i < testTexts.length; i++) {
                    const result = await wm.process(prompt, testTexts[i], schema);
                    log(`Sentiment ${i+1}: ${JSON.stringify(result, null, 2)}`, 'success');
                }
            } catch (error) {
                log(`Sentiment analysis failed: ${error.message}`, 'error');
            }
        }

        async function testDataExtraction() {
            try {
                log('Testing data extraction...');
                const messyData = "Contact John Smith at john.smith@company.com or call 555-123-4567. He works at Tech Corp, 123 Main St, San Francisco, CA 94105. Meeting scheduled for March 15th at 2:30 PM.";
                const prompt = "Extract all structured information from this text";
                const schema = {
                    name: "person's full name",
                    email: "email address",
                    phone: "phone number",
                    company: "company name",
                    address: "full address",
                    meetingDate: "meeting date",
                    meetingTime: "meeting time"
                };
                
                showTestData('Data Extraction', prompt, messyData, schema);
                
                const result = await wm.process(prompt, messyData, schema);
                log(`Data extraction result: ${JSON.stringify(result, null, 2)}`, 'success');
            } catch (error) {
                log(`Data extraction failed: ${error.message}`, 'error');
            }
        }

        async function testComplexProcessing() {
            try {
                log('Testing complex data processing...');
                const salesData = {
                    regions: [
                        { name: "North", q1: 15000, q2: 18000, q3: 12000, q4: 22000 },
                        { name: "South", q1: 12000, q2: 14000, q3: 16000, q4: 18000 },
                        { name: "East", q1: 20000, q2: 19000, q3: 21000, q4: 25000 },
                        { name: "West", q1: 8000, q2: 9500, q3: 11000, q4: 13000 }
                    ]
                };
                const prompt = "Analyze this sales data and provide insights";
                const schema = {
                    totalSales: "total sales across all regions and quarters",
                    bestRegion: "region with highest total sales",
                    worstRegion: "region with lowest total sales",
                    growthTrend: "overall growth trend analysis",
                    quarterlyTrends: "object with trends for each quarter",
                    recommendations: "array of actionable business recommendations"
                };
                
                showTestData('Complex Processing', prompt, salesData, schema);
                
                const result = await wm.process(prompt, salesData, schema);
                log(`Complex processing result: ${JSON.stringify(result, null, 2)}`, 'success');
            } catch (error) {
                log(`Complex processing failed: ${error.message}`, 'error');
            }
        }

        async function testProcessingEdgeCases() {
            try {
                log('Testing edge cases...');
                
                // Test 1: Empty data
                log('Testing with null data...');
                const prompt1 = "Generate a random person";
                const schema1 = {
                    name: "random full name",
                    age: "age between 18-65",
                    profession: "realistic job title"
                };
                showTestData('Edge Case: Null Data', prompt1, null, schema1);
                
                const result1 = await wm.process(prompt1, null, schema1);
                log(`Null data result: ${JSON.stringify(result1, null, 2)}`, 'success');
                
                // Test 2: Array data
                log('Testing with array data...');
                const arrayData = ["apple", "banana", "cherry", "date", "elderberry"];
                const prompt2 = "Categorize and analyze these fruits";
                const schema2 = {
                    count: "total number of fruits",
                    categories: "object grouping fruits by some criteria",
                    alphabetical: "fruits sorted alphabetically",
                    healthiest: "which fruit is considered healthiest"
                };
                showTestData('Edge Case: Array Data', prompt2, arrayData, schema2);
                
                const result2 = await wm.process(prompt2, arrayData, schema2);
                log(`Array data result: ${JSON.stringify(result2, null, 2)}`, 'success');
                
                // Test 3: Mixed language data
                log('Testing with mixed language data...');
                const mixedData = "Hello world! Bonjour le monde! Hola mundo! „Åì„Çì„Å´„Å°„ÅØ‰∏ñÁïåÔºÅ";
                const prompt3 = "Identify and translate languages";
                const schema3 = {
                    languages: "array of detected languages",
                    translations: "object with English translations",
                    mainLanguage: "most likely primary language"
                };
                showTestData('Edge Case: Mixed Languages', prompt3, mixedData, schema3);
                
                const result3 = await wm.process(prompt3, mixedData, schema3);
                log(`Mixed language result: ${JSON.stringify(result3, null, 2)}`, 'success');
                
                // Test 4: Large structured data
                log('Testing with large structured data...');
                const largeData = {
                    users: Array.from({length: 50}, (_, i) => ({
                        id: i + 1,
                        score: Math.floor(Math.random() * 100),
                        active: Math.random() > 0.3
                    }))
                };
                const prompt4 = "Summarize user statistics";
                const schema4 = {
                    totalUsers: "total number of users",
                    activeUsers: "number of active users",
                    averageScore: "average score of all users",
                    topScorers: "array of top 5 user IDs by score",
                    summary: "brief summary of the data"
                };
                showTestData('Edge Case: Large Dataset', prompt4, `{users: [50 user objects with id, score, active]}`, schema4);
                
                const result4 = await wm.process(prompt4, largeData, schema4);
                log(`Large data result: ${JSON.stringify(result4, null, 2)}`, 'success');
                
            } catch (error) {
                log(`Edge cases test failed: ${error.message}`, 'error');
            }
        }

        // Tool Call Inspection Tests
        async function testToolCallbacks() {
            try {
                log('üîß Testing tool call callbacks...');
                
                // Ensure tools are registered
                if (!wm._tools || wm._tools.length === 0) {
                    registerTestTools();
                }
                
                // Show the monitor
                const monitorDiv = document.getElementById('toolCallMonitor');
                monitorDiv.style.display = 'block';
                
                const logDiv = document.getElementById('toolCallLog');
                logDiv.innerHTML = '<div style="color: #666;">Monitoring tool calls...</div>';
                
                let toolCallCount = 0;
                
                const response = await wm.chat("What's the weather in Tokyo and calculate 20% of 500?", {
                    onToolCall: (call) => {
                        toolCallCount++;
                        const entry = document.createElement('div');
                        entry.style.color = '#0066cc';
                        entry.innerHTML = `üîß Tool ${toolCallCount}: <strong>${call.name}</strong><br>
                            <small>Parameters: ${JSON.stringify(call.parameters)}<br>
                            Time: ${new Date(call.timestamp).toLocaleTimeString()}</small>`;
                        logDiv.appendChild(entry);
                        log(`Tool called: ${call.name}`, 'info');
                    },
                    onToolResult: (result) => {
                        const entry = document.createElement('div');
                        entry.style.color = '#00aa00';
                        entry.innerHTML = `‚úÖ <strong>${result.name}</strong> completed (${result.duration}ms)<br>
                            <small>Result: ${JSON.stringify(result.result).substring(0, 100)}...</small>`;
                        logDiv.appendChild(entry);
                        log(`Tool completed: ${result.name} in ${result.duration}ms`, 'success');
                    },
                    onToolError: (error) => {
                        const entry = document.createElement('div');
                        entry.style.color = '#cc0000';
                        entry.innerHTML = `‚ùå <strong>${error.name}</strong> failed (${error.duration}ms)<br>
                            <small>Error: ${error.error}</small>`;
                        logDiv.appendChild(entry);
                        log(`Tool failed: ${error.name} - ${error.error}`, 'error');
                    }
                });
                
                log(`‚úÖ Tool callbacks test completed. Response: "${response}"`, 'success');
                log(`Total tool calls monitored: ${toolCallCount}`, 'info');
                
            } catch (error) {
                log(`‚ùå Tool callbacks test failed: ${error.message}`, 'error');
            }
        }

        async function testMetadataReturn() {
            try {
                log('üìä Testing metadata return feature...');
                
                // Ensure tools are registered
                if (!wm._tools || wm._tools.length === 0) {
                    registerTestTools();
                }
                
                const result = await wm.chat("What's the weather in London and calculate 15% of 200?", {
                    returnMetadata: true
                });
                
                log('‚úÖ Metadata return test completed:', 'success');
                log(`Response: "${result.response}"`, 'success');
                log('Metadata:', 'info');
                log(`- Total Duration: ${result.metadata.totalDuration}ms`, 'info');
                log(`- Tokens Used: ${result.metadata.tokensUsed || 'N/A'}`, 'info');
                log(`- Tool Calls: ${result.metadata.toolCalls.length}`, 'info');
                
                result.metadata.toolCalls.forEach((call, index) => {
                    log(`  ${index + 1}. ${call.name}: ${call.success ? 'success' : 'failed'} (${call.duration}ms)`, 'info');
                    if (call.parameters) {
                        log(`     Parameters: ${JSON.stringify(call.parameters)}`, 'info');
                    }
                });
                
            } catch (error) {
                log(`‚ùå Metadata return test failed: ${error.message}`, 'error');
            }
        }

        async function testStreamingWithCallbacks() {
            try {
                log('üåä Testing streaming with tool call callbacks...');
                
                // Ensure tools are registered
                if (!wm._tools || wm._tools.length === 0) {
                    registerTestTools();
                }
                
                // Show the monitor
                const monitorDiv = document.getElementById('toolCallMonitor');
                monitorDiv.style.display = 'block';
                
                const logDiv = document.getElementById('toolCallLog');
                logDiv.innerHTML = '<div style="color: #666;">Monitoring streaming with tools...</div>';
                
                let chunks = [];
                let toolCalls = 0;
                
                const response = await wm.streamChat(
                    "Stream the weather for Madrid and calculate 25% of 300",
                    (chunk) => {
                        chunks.push(chunk.content);
                        // Don't log every chunk to avoid spam, just update count
                    },
                    {
                        onToolCall: (call) => {
                            toolCalls++;
                            const entry = document.createElement('div');
                            entry.style.color = '#0066cc';
                            entry.innerHTML = `üîß [Stream] Tool: <strong>${call.name}</strong><br>
                                <small>Parameters: ${JSON.stringify(call.parameters)}</small>`;
                            logDiv.appendChild(entry);
                            log(`Streaming tool called: ${call.name}`, 'info');
                        },
                        onToolResult: (result) => {
                            const entry = document.createElement('div');
                            entry.style.color = '#00aa00';
                            entry.innerHTML = `‚úÖ [Stream] <strong>${result.name}</strong> completed (${result.duration}ms)`;
                            logDiv.appendChild(entry);
                            log(`Streaming tool completed: ${result.name}`, 'success');
                        },
                        onToolError: (error) => {
                            const entry = document.createElement('div');
                            entry.style.color = '#cc0000';
                            entry.innerHTML = `‚ùå [Stream] <strong>${error.name}</strong> failed: ${error.error}`;
                            logDiv.appendChild(entry);
                            log(`Streaming tool failed: ${error.name}`, 'error');
                        }
                    }
                );
                
                log(`‚úÖ Streaming with callbacks completed`, 'success');
                log(`Total chunks received: ${chunks.length}`, 'info');
                log(`Tools called during streaming: ${toolCalls}`, 'info');
                log(`Final response: "${response}"`, 'success');
                
            } catch (error) {
                log(`‚ùå Streaming with callbacks test failed: ${error.message}`, 'error');
            }
        }

        function clearToolMonitor() {
            const logDiv = document.getElementById('toolCallLog');
            const monitorDiv = document.getElementById('toolCallMonitor');
            
            logDiv.innerHTML = '<div style="color: #666;">Tool call monitor cleared</div>';
            setTimeout(() => {
                monitorDiv.style.display = 'none';
            }, 1000);
            
            log('üóëÔ∏è Tool call monitor cleared', 'success');
        }

        // Initialize and run basic connectivity test
        async function initTests() {
            log('üöÄ Initializing WarpMind test suite...');
            log(`Current server: ${currentConfig.baseURL}`);
            if (currentConfig.apiKey) {
                log(`Using API key: ${currentConfig.apiKey.substring(0, 8)}...`);
            } else {
                log('No API key configured - will prompt automatically when needed');
            }
            
            // Initialize form with current config
            initializeForm();
            
            // Test connection
            await testConnection();
        }

        // Test connection with current configuration
        async function testConnection() {
            log('Testing connectivity...');
            
            try {
                const response = await wm.chat('Hello, are you working?');
                log('‚úÖ Connectivity test passed!', 'success');
                log(`Response: "${response}"`, 'success');
                log('üéØ Ready to run full test suite!', 'success');
                showConfigStatus('Connected successfully!', 'success');
            } catch (error) {
                log(`‚ùå Connectivity failed: ${error.message}`, 'error');
                log('Check your server URL and API key in the configuration section above', 'error');
                showConfigStatus('Connection failed - check configuration', 'error');
            }
        }

        // Run initialization
        initTests();
    </script>
</body>
</html>
