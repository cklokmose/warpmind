<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete Warpmind Test Suite</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 1000px; margin: 0 auto; padding: 20px; }
        .test-section { border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 5px; }
        .test-section h2 { margin-top: 0; color: #333; }
        button { padding: 10px 15px; margin: 5px; font-size: 14px; cursor: pointer; }
        .success { background-color: #d4edda; border-color: #c3e6cb; color: #155724; }
        .error { background-color: #f8d7da; border-color: #f5c6cb; color: #721c24; }
        .info { background-color: #d1ecf1; border-color: #bee5eb; color: #0c5460; }
        #output { background: #f8f9fa; padding: 15px; margin: 10px 0; border-radius: 5px; 
                 max-height: 400px; overflow-y: auto; font-family: monospace; white-space: pre-wrap; }
        .recording { background-color: #dc3545 !important; color: white; }
        input[type="file"] { margin: 10px 0; }
        textarea { width: 100%; height: 60px; margin: 5px 0; }
        .test-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        @media (max-width: 768px) { .test-grid { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <h1>üöÄ Complete Warpmind Test Suite</h1>
    <p>Testing all functionality with configurable proxy server settings</p>
    
    <!-- Configuration Section -->
    <div class="test-section" style="background-color: #f8f9fa; border: 2px solid #007cba;">
        <h2>‚öôÔ∏è Configuration</h2>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
            <div>
                <label for="serverURL" style="display: block; margin-bottom: 5px; font-weight: bold;">Proxy Server URL:</label>
                <input type="text" id="serverURL" placeholder="http://localhost:8080 (auto-adds /v1)" 
                       style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
            </div>
            <div>
                <label for="apiKeyInput" style="display: block; margin-bottom: 5px; font-weight: bold;">Proxy Authentication Key:</label>
                <input type="password" id="apiKeyInput" placeholder="Enter your proxy key" 
                       style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
            </div>
        </div>
        <div style="text-align: center;">
            <button onclick="updateConfiguration()" style="background-color: #007cba; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin-right: 10px;">
                üîÑ Update Configuration
            </button>
            <button onclick="resetConfiguration()" style="background-color: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer;">
                üîÑ Reset to Defaults
            </button>
        </div>
        <div id="configStatus" style="margin-top: 10px; padding: 10px; border-radius: 4px; text-align: center; display: none;"></div>
    </div>
    
    <div id="output">Initializing tests...</div>

    <div class="test-grid">
        <!-- Basic Tests -->
        <div class="test-section">
            <h2>üìù Basic Text Functions</h2>
            <button onclick="testChat()">Test Chat</button>
            <button onclick="testCompletion()">Test Completion</button>
            <button onclick="testStreaming()">Test Streaming</button>
            <textarea id="chatInput" placeholder="Enter your message here...">Hello, how are you?</textarea>
        </div>

        <!-- Image Analysis -->
        <div class="test-section">
            <h2>üñºÔ∏è Image Analysis</h2>
            <input type="file" id="imageFile" accept="image/*">
            <button onclick="testImageAnalysis()">Analyze Image</button>
            <button onclick="testImageURL()">Test with URL</button>
            <textarea id="imagePrompt" placeholder="What to ask about the image...">What do you see in this image?</textarea>
        </div>

        <!-- Text to Speech -->
        <div class="test-section">
            <h2>üîä Text-to-Speech</h2>
            <button onclick="testTTS()">Generate Speech</button>
            <button onclick="testTTSVoices()">Test Different Voices</button>
            <textarea id="ttsText" placeholder="Text to convert to speech...">Hello, this is a test of text to speech functionality.</textarea>
        </div>

        <!-- Speech to Text -->
        <div class="test-section">
            <h2>üé§ Speech-to-Text</h2>
            <button id="recordBtn" onclick="startRecording()">üé§ Start Recording</button>
            <button id="stopBtn" onclick="stopRecording()" disabled>‚èπÔ∏è Stop Recording</button>
            <input type="file" id="audioFile" accept="audio/*">
            <button onclick="testSTTFile()">Test Audio File</button>
        </div>

        <!-- Voice Chat -->
        <div class="test-section">
            <h2>üí¨ Voice Chat</h2>
            <button id="voiceStartBtn" onclick="startVoiceChat()">üé§ Start Voice Chat</button>
            <button id="voiceStopBtn" onclick="stopVoiceChat()" disabled>‚èπÔ∏è Stop Voice Chat</button>
            <button onclick="clearVoiceChat()">üóëÔ∏è Clear History</button>
            <textarea id="systemPrompt" placeholder="System prompt...">You are a helpful assistant. Keep responses brief.</textarea>
        </div>

        <!-- Structured Data Processing -->
        <div class="test-section">
            <h2>üîß Structured Data Processing</h2>
            <button onclick="testSimpleProcess()">Simple Processing</button>
            <button onclick="testSentimentAnalysis()">Sentiment Analysis</button>
            <button onclick="testDataExtraction()">Data Extraction</button>
            <button onclick="testComplexProcessing()">Complex Processing</button>
            <button onclick="testProcessingEdgeCases()">Edge Cases</button>
            <div id="currentTest" style="background: #e9ecef; padding: 10px; margin: 10px 0; border-radius: 4px; font-family: monospace; font-size: 12px; max-height: 150px; overflow-y: auto; display: none;">
                <strong>Current Test Data:</strong>
                <div id="testData"></div>
            </div>
        </div>

        <!-- Stress Tests -->
        <div class="test-section">
            <h2>‚ö° Performance Tests</h2>
            <button onclick="runStressTest()">Run Stress Test</button>
            <button onclick="testConcurrency()">Test Concurrent Requests</button>
            <button onclick="testLargeFile()">Test Large Audio File</button>
        </div>
    </div>

    <script src="../dist/warpmind.js"></script>
    <script>
        // Configuration management
        const DEFAULT_CONFIG = {
            baseURL: 'http://localhost:8080/v1',
            apiKey: 'test-api-key-123'
        };

        // Load configuration from localStorage or use defaults
        function loadConfiguration() {
            const savedConfig = localStorage.getItem('warpmind-test-config');
            if (savedConfig) {
                try {
                    return JSON.parse(savedConfig);
                } catch (e) {
                    console.warn('Failed to parse saved config, using defaults');
                    return DEFAULT_CONFIG;
                }
            }
            return DEFAULT_CONFIG;
        }

        // Save configuration to localStorage
        function saveConfiguration(config) {
            localStorage.setItem('warpmind-test-config', JSON.stringify(config));
        }

        // Initialize configuration
        let currentConfig = loadConfiguration();
        
        // Initialize Warpmind with current configuration
        let wm = new Warpmind(currentConfig);

        // Update configuration from form inputs
        function updateConfiguration() {
            const serverURL = document.getElementById('serverURL').value.trim();
            const apiKey = document.getElementById('apiKeyInput').value.trim();
            
            if (!serverURL || !apiKey) {
                showConfigStatus('Please fill in both server URL and API key', 'error');
                return;
            }

            // Automatically append /v1 if not present
            const formattedURL = serverURL.endsWith('/v1') ? serverURL : serverURL.replace(/\/$/, '') + '/v1';

            currentConfig = { baseURL: formattedURL, apiKey: apiKey };
            saveConfiguration(currentConfig);
            
            // Reinitialize Warpmind with new config
            wm = new Warpmind(currentConfig);
            
            showConfigStatus('Configuration updated successfully!', 'success');
            log('üîÑ Configuration updated and saved to localStorage');
            log(`üåê Using server: ${formattedURL}`);
            
            // Test the new configuration
            testConnection();
        }

        // Reset configuration to defaults
        function resetConfiguration() {
            currentConfig = { ...DEFAULT_CONFIG };
            saveConfiguration(currentConfig);
            
            // Update form inputs (show URL without /v1 for better UX)
            const displayURL = currentConfig.baseURL.endsWith('/v1') 
                ? currentConfig.baseURL.slice(0, -3) 
                : currentConfig.baseURL;
            document.getElementById('serverURL').value = displayURL;
            document.getElementById('apiKeyInput').value = currentConfig.apiKey;
            
            // Reinitialize Warpmind
            wm = new Warpmind(currentConfig);
            
            showConfigStatus('Configuration reset to defaults', 'info');
            log('üîÑ Configuration reset to defaults');
            
            // Test the configuration
            testConnection();
        }

        // Show configuration status message
        function showConfigStatus(message, type) {
            const statusDiv = document.getElementById('configStatus');
            statusDiv.style.display = 'block';
            statusDiv.textContent = message;
            statusDiv.className = type;
            
            // Hide after 3 seconds
            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 3000);
        }

        // Initialize form inputs with current configuration
        function initializeForm() {
            // Show URL without /v1 in the form for better UX
            const displayURL = currentConfig.baseURL.endsWith('/v1') 
                ? currentConfig.baseURL.slice(0, -3) 
                : currentConfig.baseURL;
            document.getElementById('serverURL').value = displayURL;
            document.getElementById('apiKeyInput').value = currentConfig.apiKey;
        }

        const output = document.getElementById('output');
        let voiceChat = null;
        let isRecording = false;
        let mediaRecorder = null;
        let audioChunks = [];

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : '‚ÑπÔ∏è';
            output.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            output.scrollTop = output.scrollHeight;
        }

        function clearLog() {
            output.textContent = '';
        }

        // Show what data is being processed in each test
        function showTestData(testName, prompt, data, schema) {
            const testDiv = document.getElementById('currentTest');
            const dataDiv = document.getElementById('testData');
            
            let dataDisplay = '';
            if (data === null) {
                dataDisplay = 'null (no input data)';
            } else if (typeof data === 'string') {
                dataDisplay = `"${data}"`;
            } else {
                dataDisplay = JSON.stringify(data, null, 2);
            }
            
            dataDiv.innerHTML = `
                <div><strong>Test:</strong> ${testName}</div>
                <div><strong>Prompt:</strong> "${prompt}"</div>
                <div><strong>Input Data:</strong> ${dataDisplay}</div>
                <div><strong>Expected Schema:</strong> ${JSON.stringify(schema, null, 2)}</div>
            `;
            
            testDiv.style.display = 'block';
        }

        // Basic Text Tests
        async function testChat() {
            try {
                log('Testing basic chat...');
                const message = document.getElementById('chatInput').value;
                const response = await wm.chat(message);
                log(`Chat response: "${response}"`, 'success');
            } catch (error) {
                log(`Chat failed: ${error.message}`, 'error');
            }
        }

        async function testCompletion() {
            try {
                log('Testing completion...');
                const response = await wm.complete('The sky is');
                log(`Completion response: "${response}"`, 'success');
            } catch (error) {
                log(`Completion failed: ${error.message}`, 'error');
            }
        }

        async function testStreaming() {
            try {
                log('Testing streaming chat...');
                let streamedText = '';
                await wm.streamChat('Tell me a short joke', (chunk) => {
                    streamedText += chunk;
                });
                log(`Streamed response: "${streamedText}"`, 'success');
            } catch (error) {
                log(`Streaming failed: ${error.message}`, 'error');
            }
        }

        // Image Analysis Tests
        async function testImageAnalysis() {
            const file = document.getElementById('imageFile').files[0];
            if (!file) {
                log('Please select an image file first', 'error');
                return;
            }

            try {
                log(`Analyzing image: ${file.name}...`);
                const prompt = document.getElementById('imagePrompt').value;
                const response = await wm.analyzeImage(file, prompt);
                log(`Image analysis: "${response}"`, 'success');
            } catch (error) {
                log(`Image analysis failed: ${error.message}`, 'error');
            }
        }

        async function testImageURL() {
            try {
                log('Testing image analysis with URL...');
                const prompt = document.getElementById('imagePrompt').value;
                const response = await wm.analyzeImage(
                    'https://upload.wikimedia.org/wikipedia/commons/thumb/d/dd/Gfp-wisconsin-madison-the-nature-boardwalk.jpg/2560px-Gfp-wisconsin-madison-the-nature-boardwalk.jpg',
                    prompt
                );
                log(`URL image analysis: "${response}"`, 'success');
            } catch (error) {
                log(`URL image analysis failed: ${error.message}`, 'error');
            }
        }

        // TTS Tests
        async function testTTS() {
            try {
                log('Testing text-to-speech...');
                const text = document.getElementById('ttsText').value;
                const audioBlob = await wm.textToSpeech(text);
                log(`TTS successful: ${audioBlob.size} bytes`, 'success');
                
                // Play the audio
                await wm.playAudio(audioBlob);
                log('TTS audio played successfully', 'success');
            } catch (error) {
                log(`TTS failed: ${error.message}`, 'error');
            }
        }

        async function testTTSVoices() {
            const voices = ['alloy', 'echo', 'fable', 'onyx', 'nova', 'shimmer'];
            const text = 'Testing different voices';
            
            for (const voice of voices) {
                try {
                    log(`Testing TTS with voice: ${voice}...`);
                    const audioBlob = await wm.textToSpeech(text, { voice });
                    log(`Voice ${voice}: ${audioBlob.size} bytes`, 'success');
                } catch (error) {
                    log(`Voice ${voice} failed: ${error.message}`, 'error');
                }
            }
        }

        // STT Tests
        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                mediaRecorder.start();
                isRecording = true;
                
                document.getElementById('recordBtn').disabled = true;
                document.getElementById('recordBtn').classList.add('recording');
                document.getElementById('stopBtn').disabled = false;
                
                log('üé§ Recording started... Speak now!');
            } catch (error) {
                log(`Recording failed: ${error.message}`, 'error');
            }
        }

        async function stopRecording() {
            if (!isRecording || !mediaRecorder) return;

            mediaRecorder.onstop = async () => {
                try {
                    log('‚è≥ Processing recorded audio...');
                    const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                    
                    const transcription = await wm.speechToText(audioBlob);
                    log(`STT result: "${transcription}"`, 'success');
                    
                } catch (error) {
                    log(`STT failed: ${error.message}`, 'error');
                } finally {
                    // Clean up
                    mediaRecorder.stream.getTracks().forEach(track => track.stop());
                    isRecording = false;
                    document.getElementById('recordBtn').disabled = false;
                    document.getElementById('recordBtn').classList.remove('recording');
                    document.getElementById('stopBtn').disabled = true;
                }
            };

            mediaRecorder.stop();
        }

        async function testSTTFile() {
            const file = document.getElementById('audioFile').files[0];
            if (!file) {
                log('Please select an audio file first', 'error');
                return;
            }

            try {
                log(`Transcribing file: ${file.name}...`);
                const transcription = await wm.speechToText(file);
                log(`File STT result: "${transcription}"`, 'success');
            } catch (error) {
                log(`File STT failed: ${error.message}`, 'error');
            }
        }

        // Voice Chat Tests
        async function startVoiceChat() {
            try {
                const systemPrompt = document.getElementById('systemPrompt').value;
                voiceChat = wm.createVoiceChat(systemPrompt);
                
                await voiceChat.startRecording();
                
                document.getElementById('voiceStartBtn').disabled = true;
                document.getElementById('voiceStartBtn').classList.add('recording');
                document.getElementById('voiceStopBtn').disabled = false;
                
                log('üé§ Voice chat started... Speak your message!');
            } catch (error) {
                log(`Voice chat start failed: ${error.message}`, 'error');
            }
        }

        async function stopVoiceChat() {
            if (!voiceChat) return;

            try {
                log('‚è≥ Processing voice chat...');
                const result = await voiceChat.stopRecordingAndRespond();
                
                log(`You said: "${result.userMessage}"`, 'success');
                log(`AI replied: "${result.aiResponse}"`, 'success');
                
                // Play AI response
                await wm.playAudio(result.speechBlob);
                log('AI response played', 'success');
                
            } catch (error) {
                log(`Voice chat failed: ${error.message}`, 'error');
            } finally {
                document.getElementById('voiceStartBtn').disabled = false;
                document.getElementById('voiceStartBtn').classList.remove('recording');
                document.getElementById('voiceStopBtn').disabled = true;
            }
        }

        function clearVoiceChat() {
            if (voiceChat) {
                voiceChat.clearConversation();
                log('Voice chat history cleared', 'success');
            }
        }

        // Performance Tests
        async function runStressTest() {
            log('üî• Starting stress test...');
            const promises = [];
            
            // Multiple concurrent requests
            for (let i = 0; i < 5; i++) {
                promises.push(wm.chat(`Test message ${i + 1}`));
            }
            
            try {
                const results = await Promise.all(promises);
                log(`Stress test completed: ${results.length} responses`, 'success');
            } catch (error) {
                log(`Stress test failed: ${error.message}`, 'error');
            }
        }

        async function testConcurrency() {
            log('‚ö° Testing concurrent different operations...');
            
            try {
                const [chatResult, ttsResult, completionResult] = await Promise.all([
                    wm.chat('Quick test'),
                    wm.textToSpeech('Concurrent test'),
                    wm.complete('The weather is')
                ]);
                
                log('Concurrent operations completed successfully', 'success');
                log(`Chat: "${chatResult}"`, 'success');
                log(`TTS: ${ttsResult.size} bytes`, 'success');
                log(`Completion: "${completionResult}"`, 'success');
            } catch (error) {
                log(`Concurrency test failed: ${error.message}`, 'error');
            }
        }

        async function testLargeFile() {
            // Create a synthetic large audio file (silence)
            try {
                log('Testing with large audio file...');
                const audioContext = new AudioContext();
                const sampleRate = 44100;
                const duration = 10; // 10 seconds
                const numChannels = 1;
                const length = sampleRate * duration * numChannels;
                
                const audioBuffer = audioContext.createBuffer(numChannels, length, sampleRate);
                
                // Fill with low-volume noise
                for (let channel = 0; channel < numChannels; channel++) {
                    const channelData = audioBuffer.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        channelData[i] = (Math.random() - 0.5) * 0.1;
                    }
                }
                
                // Convert to WAV blob (simplified)
                const blob = new Blob([new ArrayBuffer(1000000)], { type: 'audio/wav' });
                
                const transcription = await wm.speechToText(blob);
                log(`Large file STT result: "${transcription}"`, 'success');
            } catch (error) {
                log(`Large file test failed: ${error.message}`, 'error');
            }
        }

        // Process Method Tests
        async function testSimpleProcess() {
            try {
                log('Testing simple process method...');
                const data = "I just received my order and I'm really impressed! The quality is excellent and it arrived faster than expected. Definitely recommend this to others.";
                const prompt = "Analyze this text";
                const schema = {
                    sentiment: "positive, negative, or neutral",
                    confidence: "confidence score from 0 to 1",
                    wordCount: "number of words"
                };
                
                showTestData('Simple Processing', prompt, data, schema);
                
                const result = await wm.process(prompt, data, schema);
                log(`Simple process result: ${JSON.stringify(result, null, 2)}`, 'success');
            } catch (error) {
                log(`Simple process failed: ${error.message}`, 'error');
            }
        }

        async function testSentimentAnalysis() {
            try {
                log('Testing sentiment analysis...');
                const testTexts = [
                    "I absolutely love this product! Best purchase ever!",
                    "This is terrible. Worst experience of my life.",
                    "It's okay, nothing special but not bad either."
                ];
                const prompt = "Analyze the sentiment and emotions";
                const schema = {
                    sentiment: "positive, negative, or neutral",
                    emotions: "array of detected emotions",
                    intensity: "emotional intensity from 1-10",
                    keywords: "array of important sentiment words"
                };
                
                showTestData('Sentiment Analysis', prompt, testTexts, schema);
                
                for (let i = 0; i < testTexts.length; i++) {
                    const result = await wm.process(prompt, testTexts[i], schema);
                    log(`Sentiment ${i+1}: ${JSON.stringify(result, null, 2)}`, 'success');
                }
            } catch (error) {
                log(`Sentiment analysis failed: ${error.message}`, 'error');
            }
        }

        async function testDataExtraction() {
            try {
                log('Testing data extraction...');
                const messyData = "Contact John Smith at john.smith@company.com or call 555-123-4567. He works at Tech Corp, 123 Main St, San Francisco, CA 94105. Meeting scheduled for March 15th at 2:30 PM.";
                const prompt = "Extract all structured information from this text";
                const schema = {
                    name: "person's full name",
                    email: "email address",
                    phone: "phone number",
                    company: "company name",
                    address: "full address",
                    meetingDate: "meeting date",
                    meetingTime: "meeting time"
                };
                
                showTestData('Data Extraction', prompt, messyData, schema);
                
                const result = await wm.process(prompt, messyData, schema);
                log(`Data extraction result: ${JSON.stringify(result, null, 2)}`, 'success');
            } catch (error) {
                log(`Data extraction failed: ${error.message}`, 'error');
            }
        }

        async function testComplexProcessing() {
            try {
                log('Testing complex data processing...');
                const salesData = {
                    regions: [
                        { name: "North", q1: 15000, q2: 18000, q3: 12000, q4: 22000 },
                        { name: "South", q1: 12000, q2: 14000, q3: 16000, q4: 18000 },
                        { name: "East", q1: 20000, q2: 19000, q3: 21000, q4: 25000 },
                        { name: "West", q1: 8000, q2: 9500, q3: 11000, q4: 13000 }
                    ]
                };
                const prompt = "Analyze this sales data and provide insights";
                const schema = {
                    totalSales: "total sales across all regions and quarters",
                    bestRegion: "region with highest total sales",
                    worstRegion: "region with lowest total sales",
                    growthTrend: "overall growth trend analysis",
                    quarterlyTrends: "object with trends for each quarter",
                    recommendations: "array of actionable business recommendations"
                };
                
                showTestData('Complex Processing', prompt, salesData, schema);
                
                const result = await wm.process(prompt, salesData, schema);
                log(`Complex processing result: ${JSON.stringify(result, null, 2)}`, 'success');
            } catch (error) {
                log(`Complex processing failed: ${error.message}`, 'error');
            }
        }

        async function testProcessingEdgeCases() {
            try {
                log('Testing edge cases...');
                
                // Test 1: Empty data
                log('Testing with null data...');
                const prompt1 = "Generate a random person";
                const schema1 = {
                    name: "random full name",
                    age: "age between 18-65",
                    profession: "realistic job title"
                };
                showTestData('Edge Case: Null Data', prompt1, null, schema1);
                
                const result1 = await wm.process(prompt1, null, schema1);
                log(`Null data result: ${JSON.stringify(result1, null, 2)}`, 'success');
                
                // Test 2: Array data
                log('Testing with array data...');
                const arrayData = ["apple", "banana", "cherry", "date", "elderberry"];
                const prompt2 = "Categorize and analyze these fruits";
                const schema2 = {
                    count: "total number of fruits",
                    categories: "object grouping fruits by some criteria",
                    alphabetical: "fruits sorted alphabetically",
                    healthiest: "which fruit is considered healthiest"
                };
                showTestData('Edge Case: Array Data', prompt2, arrayData, schema2);
                
                const result2 = await wm.process(prompt2, arrayData, schema2);
                log(`Array data result: ${JSON.stringify(result2, null, 2)}`, 'success');
                
                // Test 3: Mixed language data
                log('Testing with mixed language data...');
                const mixedData = "Hello world! Bonjour le monde! Hola mundo! „Åì„Çì„Å´„Å°„ÅØ‰∏ñÁïåÔºÅ";
                const prompt3 = "Identify and translate languages";
                const schema3 = {
                    languages: "array of detected languages",
                    translations: "object with English translations",
                    mainLanguage: "most likely primary language"
                };
                showTestData('Edge Case: Mixed Languages', prompt3, mixedData, schema3);
                
                const result3 = await wm.process(prompt3, mixedData, schema3);
                log(`Mixed language result: ${JSON.stringify(result3, null, 2)}`, 'success');
                
                // Test 4: Large structured data
                log('Testing with large structured data...');
                const largeData = {
                    users: Array.from({length: 50}, (_, i) => ({
                        id: i + 1,
                        score: Math.floor(Math.random() * 100),
                        active: Math.random() > 0.3
                    }))
                };
                const prompt4 = "Summarize user statistics";
                const schema4 = {
                    totalUsers: "total number of users",
                    activeUsers: "number of active users",
                    averageScore: "average score of all users",
                    topScorers: "array of top 5 user IDs by score",
                    summary: "brief summary of the data"
                };
                showTestData('Edge Case: Large Dataset', prompt4, `{users: [50 user objects with id, score, active]}`, schema4);
                
                const result4 = await wm.process(prompt4, largeData, schema4);
                log(`Large data result: ${JSON.stringify(result4, null, 2)}`, 'success');
                
            } catch (error) {
                log(`Edge cases test failed: ${error.message}`, 'error');
            }
        }

        // Initialize and run basic connectivity test
        async function initTests() {
            log('üöÄ Initializing Warpmind test suite...');
            log(`Current server: ${currentConfig.baseURL}`);
            log(`Using API key: ${currentConfig.apiKey.substring(0, 8)}...`);
            
            // Initialize form with current config
            initializeForm();
            
            // Test connection
            await testConnection();
        }

        // Test connection with current configuration
        async function testConnection() {
            log('Testing connectivity...');
            
            try {
                const response = await wm.chat('Hello, are you working?');
                log('‚úÖ Connectivity test passed!', 'success');
                log(`Response: "${response}"`, 'success');
                log('üéØ Ready to run full test suite!', 'success');
                showConfigStatus('Connected successfully!', 'success');
            } catch (error) {
                log(`‚ùå Connectivity failed: ${error.message}`, 'error');
                log('Check your server URL and API key in the configuration section above', 'error');
                showConfigStatus('Connection failed - check configuration', 'error');
            }
        }

        // Run initialization
        initTests();
    </script>
</body>
</html>
