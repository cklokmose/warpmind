<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SSE Parser Demo</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 800px; margin: 0 auto; }
        .demo-section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
        .output { background: #f5f5f5; padding: 10px; margin: 10px 0; border-radius: 3px; white-space: pre-wrap; }
        .streaming-output { min-height: 100px; border: 1px solid #ccc; padding: 10px; margin: 10px 0; }
        button { padding: 10px 15px; margin: 5px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer; }
        button:hover { background: #0056b3; }
        .chunk { background: #e7f3ff; margin: 2px 0; padding: 2px 5px; border-radius: 2px; display: inline-block; }
        .event-info { font-size: 12px; color: #666; }
    </style>
</head>
<body>
    <div class="container">
        <h1>WarpMind SSE Parser Demo</h1>
        
        <div class="demo-section">
            <h3>SSE Parser Features</h3>
            <p>The new SSE parser provides:</p>
            <ul>
                <li>✅ Robust parsing using <code>eventsource-parser</code> library</li>
                <li>✅ Fallback to manual parsing if library unavailable</li>
                <li>✅ Structured event format: <code>{ role, delta }</code></li>
                <li>✅ Proper error handling for malformed streams</li>
                <li>✅ Integration with timeout and retry logic</li>
            </ul>
        </div>

        <div class="demo-section">
            <h3>Stream Chat Test</h3>
            <button onclick="testStreamChat()">Test Streaming Chat</button>
            <button onclick="testStreamChatWithTimeout()">Test with Short Timeout</button>
            <button onclick="clearOutput()">Clear Output</button>
            
            <div class="streaming-output" id="streamOutput">
                <div class="event-info">Streaming output will appear here...</div>
            </div>
            
            <div class="output" id="finalResult">Final result will appear here...</div>
        </div>

        <div class="demo-section">
            <h3>SSE Parser Internals</h3>
            <button onclick="testParseSSEDirectly()">Test parseSSE Function</button>
            <div class="output" id="parseSSEOutput">parseSSE test output will appear here...</div>
        </div>

        <div class="demo-section">
            <h3>Error Handling</h3>
            <button onclick="testSSEErrorHandling()">Test Error Handling</button>
            <div class="output" id="errorOutput">Error handling test output will appear here...</div>
        </div>
    </div>

    <script src="../dist/warpmind.js"></script>
    <script>
        const mind = new Warpmind({
            apiKey: 'demo-key',
            baseURL: 'https://api.demo.com/v1'
        });

        function log(elementId, message, append = false) {
            const element = document.getElementById(elementId);
            if (append) {
                element.innerHTML += message + '\n';
            } else {
                element.innerHTML = message + '\n';
            }
        }

        function clearOutput() {
            document.getElementById('streamOutput').innerHTML = '<div class="event-info">Streaming output will appear here...</div>';
            document.getElementById('finalResult').innerHTML = 'Final result will appear here...';
        }

        async function testStreamChat() {
            log('streamOutput', '', false);
            log('finalResult', 'Starting stream chat test...', false);
            
            let chunkCount = 0;
            const startTime = Date.now();

            // Mock fetch to simulate SSE stream
            const originalFetch = window.fetch;
            window.fetch = async (url, options) => {
                // Simulate SSE response
                const encoder = new TextEncoder();
                const chunks = [
                    'data: {"choices":[{"delta":{"content":"Hello"}}]}\n\n',
                    'data: {"choices":[{"delta":{"content":" there!"}}]}\n\n', 
                    'data: {"choices":[{"delta":{"content":" How"}}]}\n\n',
                    'data: {"choices":[{"delta":{"content":" are"}}]}\n\n',
                    'data: {"choices":[{"delta":{"content":" you?"}}]}\n\n',
                    'data: [DONE]\n\n'
                ];

                let chunkIndex = 0;
                const reader = {
                    read: async () => {
                        if (chunkIndex < chunks.length) {
                            const chunk = encoder.encode(chunks[chunkIndex++]);
                            return { done: false, value: chunk };
                        }
                        return { done: true };
                    }
                };

                return {
                    ok: true,
                    body: { getReader: () => reader }
                };
            };

            try {
                const result = await mind.streamChat('Test message', (chunk) => {
                    chunkCount++;
                    const chunkElement = document.createElement('span');
                    chunkElement.className = 'chunk';
                    chunkElement.textContent = chunk;
                    document.getElementById('streamOutput').appendChild(chunkElement);
                });

                const endTime = Date.now();
                log('finalResult', 
                    `✅ Stream completed successfully!\n` +
                    `Final result: "${result}"\n` +
                    `Chunks received: ${chunkCount}\n` +
                    `Duration: ${endTime - startTime}ms`
                );
            } catch (error) {
                log('finalResult', `❌ Error: ${error.message}`);
            } finally {
                window.fetch = originalFetch;
            }
        }

        async function testStreamChatWithTimeout() {
            log('streamOutput', '', false);
            log('finalResult', 'Testing timeout functionality...', false);

            // Mock fetch to simulate a hanging request that respects AbortController
            const originalFetch = window.fetch;
            let fetchCalled = false;
            
            window.fetch = (url, options) => {
                fetchCalled = true;
                log('finalResult', 'Fetch called with AbortController signal: ' + !!options.signal, true);
                
                return new Promise((resolve, reject) => {
                    // Check if request has an AbortController signal
                    if (options.signal) {
                        // Set up abort listener
                        options.signal.addEventListener('abort', () => {
                            log('finalResult', 'AbortController triggered!', true);
                            const abortError = new Error('The operation was aborted');
                            abortError.name = 'AbortError';
                            reject(abortError);
                        });
                        
                        // Also check if already aborted
                        if (options.signal.aborted) {
                            const abortError = new Error('The operation was aborted');
                            abortError.name = 'AbortError';
                            reject(abortError);
                            return;
                        }
                    }
                    // Don't resolve - simulate hanging request
                    // The timeout will trigger the AbortController
                    log('finalResult', 'Request hanging, waiting for timeout...', true);
                });
            };

            const startTime = Date.now();
            try {
                await mind.streamChat('Test message', null, { timeoutMs: 2000 });
                log('finalResult', '❌ Should have timed out!', true);
            } catch (error) {
                const duration = Date.now() - startTime;
                log('finalResult', `Request failed after ${duration}ms`, true);
                
                if (error.name === 'TimeoutError') {
                    log('finalResult', `✅ Timeout handled correctly: ${error.message}`, true);
                } else {
                    log('finalResult', `❌ Wrong error type: ${error.name} - ${error.message}`, true);
                }
            } finally {
                window.fetch = originalFetch;
                if (!fetchCalled) {
                    log('finalResult', '❌ Fetch was never called!', true);
                }
            }
        }

        async function testParseSSEDirectly() {
            log('parseSSEOutput', 'Testing parseSSE function directly...', false);

            // Create a mock reader
            const encoder = new TextEncoder();
            const testData = [
                'data: {"choices":[{"delta":{"content":"Direct"}}]}\n\n',
                'data: {"choices":[{"delta":{"content":" test"}}]}\n\n',
                'data: [DONE]\n\n'
            ];

            let dataIndex = 0;
            const mockReader = {
                read: async () => {
                    if (dataIndex < testData.length) {
                        return { done: false, value: encoder.encode(testData[dataIndex++]) };
                    }
                    return { done: true };
                }
            };

            const events = [];
            try {
                const result = await mind.parseSSE(mockReader, (event) => {
                    events.push(event);
                    log('parseSSEOutput', `Event: ${JSON.stringify(event)}`, true);
                });

                log('parseSSEOutput', 
                    `✅ parseSSE test completed!\n` +
                    `Final result: "${result}"\n` +
                    `Events parsed: ${events.length}`, true
                );
            } catch (error) {
                log('parseSSEOutput', `❌ Error: ${error.message}`, true);
            }
        }

        async function testSSEErrorHandling() {
            log('errorOutput', 'Testing SSE error handling...', false);

            // Test malformed JSON
            const encoder = new TextEncoder();
            const malformedData = [
                'data: {"choices":[{"delta":{"content":"Good"}}]}\n\n',
                'data: invalid json here\n\n',
                'data: {"choices":[{"delta":{"content":" data"}}]}\n\n'
            ];

            let dataIndex = 0;
            const mockReader = {
                read: async () => {
                    if (dataIndex < malformedData.length) {
                        return { done: false, value: encoder.encode(malformedData[dataIndex++]) };
                    }
                    return { done: true };
                }
            };

            // Capture console warnings
            const originalWarn = console.warn;
            const warnings = [];
            console.warn = (msg) => warnings.push(msg);

            try {
                const result = await mind.parseSSE(mockReader, (event) => {
                    log('errorOutput', `Valid event: ${JSON.stringify(event)}`, true);
                });

                log('errorOutput', 
                    `✅ Error handling test completed!\n` +
                    `Result: "${result}"\n` +
                    `Warnings captured: ${warnings.length}`, true
                );

                if (warnings.length > 0) {
                    log('errorOutput', `Console warnings:\n${warnings.join('\n')}`, true);
                }
            } catch (error) {
                log('errorOutput', `❌ Unexpected error: ${error.message}`, true);
            } finally {
                console.warn = originalWarn;
            }
        }

        // Show parser availability on load
        window.addEventListener('load', () => {
            const hasParser = typeof EventSourceParser !== 'undefined' || 
                            (typeof window !== 'undefined' && window.EventSourceParser);
            
            console.log('SSE Parser Status:', hasParser ? 'Available' : 'Using fallback');
            console.log('WarpMind SSE functionality loaded successfully!');
        });
    </script>
</body>
</html>
